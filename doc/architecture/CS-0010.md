# Constraint 0010

## Title
C++ level and standards
## Description

This constraint applies on all code written in C++, excpeting external dependencies (as coming in ext-projects).

Regarding this constraint, the following rules apply:

- Use C++17 or higher. If definitions from standards higher than C++17 are used, the code shall be compatible with C++17 (at  least regarding interfaces).
- When objects are passed by value, use move semantics instead of copy semantics.
- When objects are passed by reference, use const references instead of pointers.
- When objects are returned, use move semantics instead of copy semantics.
- When objects are shared by multiple threads, use thread-safe containers.
- When objects are shared by multiples objects whith potential different lifecycles, use shared_ptr or weak_ptr.
- For object fields not shared across multiple objects, use unique_ptr.
- For objects used in a single scope (method body or lambda body), usage of unique_ptr is optional and discouraged.
- Use zero / one / three rule for constructor parameters where it's possible.
- Use of new or delete keywords is forbidden.
- Use of malloc or free keywords is forbidden.
- Use of calloc or realloc keywords is forbidden.
- Use of realloc keywords is forbidden.
- Use of strdup or strndup keywords is forbidden.
- When functions from standard libraries relying on unbounded buffers are used, the code shall check for buffer overflow.
- When pointers are used as parameters, the code shall check for null pointers.
- Use of unbounded arrays is forbidden.
- Use of goto keywords is forbidden.
- Dead code is forbidden. This constraint is not applied to code intended to be used by external code. In this case, dead code is authorized if comments are inserted to explain the purpose of the code.
- Use of undefined behavior is forbidden.
- Use of exceptions is authorized. Use of exception is mandatory where called functions can throw exceptions. In this case, the code shall catch exceptions and handle them.
- Use of RAII is strongly recommended. Use of RAII is mandatory for mutexes.
- Use of RAII is mandatory for file handles.
- Use of RAII is mandatory for socket handles.
- Use of RAII is mandatory for memory mapped files.
- Use of RAII is recommended for memory allocation.
- Avoid usage of wait functions without timeout. When it's possible, use mutex with timeout.
- Avoid usage of sleep functions. When it's possible, use wait functions with timeout.
- Avoid usage of global variables.
- Avoid usage of global functions.
- Avoid usage of global constants.
- All declarations shall be explicit.
- All declarations shall be initialized.
- All declarations shall be contained in a namespace.
- Use of the "auto" type is strictly forbidden.
- No function body shall be longer than 80 lines.
- No class body shall be longer than 900 lines.
- Use of the "goto" statement is forbidden.
- Use of infinite loops is forbidden. Use of infinite loops is authorized when it's the only way to implement a feature. All loops shall be implemented with a hard limit on the number of iterations. When hard limit is reached, an exception should be thrown.
- Use of infinite recursion is forbidden. Use of infinite recursion is authorized when it's the only way to implement a feature. All recursive calls shall be implemented with a hard limit on the number of iterations. When hard limit is reached, an exception should be thrown.
- When possible, literals shall be replaced by constants.
- When possible, constants shall be replaced by enums.
- When possible, enums shall be replaced by templates.
- When possible, templates shall be replaced by concepts.
- When possible, concepts shall be replaced by traits.
- A comment shall be inserted in each code block to explain its purpose. No code block shall be longer than 5 lines.
- Each class, field, method and member shall be documented with Doxygen comments.

## Rationale

This constraint is intended to ensure that the code is written in a way that is easy to understand and maintain.

## Verification

- Some verifications have to be carried by running cppcheck on the code. In this case, the code shall be checked against the rules defined in this constraint. Verification shall be included in the build process.
- Some verifications have to be carried by running valgrind on the code. In this case, the code shall be checked against the rules defined in this constraint. Verification shall be included in the build process.
- Some verification have to be carried by running specially crafted commands on the code. In this case, the code shall be checked against the rules defined in this constraint. Verification shall be included in the build process.