--- interrupts.c	2014-10-17 16:29:36.000000000 +0000
+++ interrupts.c	2024-10-11 09:15:25.670188073 +0000
@@ -949,7 +949,12 @@
     unsigned long flags = ulFlags;   /* Save and restore flags with spinlocks */
     unsigned int  timeout = 0; /* Msecs converted into jiffies          */
     RFM2G_UINT8 unit = eventinfo->Unit;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+    wait_queue_entry_t wait;
+#else
     wait_queue_t wait;
+#endif
+
     RFM2G_UINT8 * orbase;
     RFM2G_UINT8 * csbase;
     RFM2GCONFIGLINUX  *cfg;    /* This RFM's config struct          */
@@ -1054,7 +1059,7 @@
         /* Go to sleep until timing out or receiving the interrupt */
         init_waitqueue_entry(&wait, current);
         add_wait_queue( &qheader->reqh_wait, &wait );
-        current->state = TASK_INTERRUPTIBLE;
+        set_current_state(TASK_INTERRUPTIBLE);
 
         /* Release lock before really going to sleep */
         WHENDEBUG(RFM2G_DBMUTEX)
@@ -1071,7 +1076,7 @@
                           !(qheader->reqh_flags & EVENT_CANCELED))
 		{
             /* Put us to sleep */
-	        current->state = TASK_INTERRUPTIBLE;
+	        set_current_state(TASK_INTERRUPTIBLE);
 
             /* Check the condition we are sleeping on prior to giving up the processor.  We will
             have a race condition if we fail to perform this check.  For additional information,
@@ -1089,7 +1094,7 @@
 						eventinfo->Event, current->pid );
 				}
 
-                current->state = TASK_RUNNING;
+                set_current_state(TASK_RUNNING);
                 break;
             }
 
@@ -1256,7 +1261,11 @@
 	unsigned long flags = ulFlags;   /* Save and restore flags with spinlocks */
 	unsigned int  timeout = 0; /* Msecs converted into jiffies          */
 	RFM2G_UINT8 unit = eventinfo->Unit;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 12, 0)
+	wait_queue_entry_t wait;
+#else
 	wait_queue_t wait;
+#endif
 	RFM2G_UINT8 * orbase;
 	RFM2G_UINT8 * csbase;
 	RFM2GCONFIGLINUX  *cfg;    /* This RFM's config struct          */
@@ -1318,7 +1327,7 @@
         	/* Go to sleep until timing out or receiving the interrupt */
         	init_waitqueue_entry(&wait, current);
         	add_wait_queue( &qheader->reqh_wait, &wait );
-        	current->state = TASK_INTERRUPTIBLE;
+        	set_current_state(TASK_INTERRUPTIBLE);
 
         	/* Release lock before really going to sleep */
         	WHENDEBUG(RFM2G_DBMUTEX)
@@ -1335,7 +1344,7 @@
                           !(qheader->reqh_flags & EVENT_CANCELED))
 		{
             	/* Put us to sleep */
-	        	current->state = TASK_INTERRUPTIBLE;
+	        	set_current_state(TASK_INTERRUPTIBLE);
 
             	/* Check the condition we are sleeping on prior to giving up the processor.  We will
             	have a race condition if we fail to perform this check.  For additional information,
@@ -1353,7 +1362,7 @@
 						eventinfo->Event, current->pid );
 				}
 
-                		current->state = TASK_RUNNING;
+                		set_current_state(TASK_RUNNING);
                 		break;
             	}
 
