/*============================================================================*
 * FILE:                  I R Q _ S E T U P . C
 *============================================================================*
 *
 *      COPYRIGHT (C) 1994 - 2017 BY ABACO SYSTEMS, INC.
 *      ALL RIGHTS RESERVED.
 *
 *      THIS SOFTWARE IS FURNISHED UNDER A LICENSE AND MAY BE USED AND
 *      COPIED ONLY IN ACCORDANCE WITH THE TERMS OF SUCH LICENSE AND WITH
 *      THE INCLUSION OF THE ABOVE COPYRIGHT NOTICE.  THIS SOFTWARE OR ANY
 *      OTHER COPIES THEREOF MAY NOT BE PROVIDED OR OTHERWISE MADE
 *      AVAILABLE TO ANY OTHER PERSON.  NO TITLE TO AND OWNERSHIP OF THE
 *      SOFTWARE IS HEREBY TRANSFERRED.
 *
 *      THE INFORMATION IN THIS SOFTWARE IS SUBJECT TO CHANGE WITHOUT
 *      NOTICE AND SHOULD NOT BE CONSTRUED AS A COMMITMENT BY ABACO SYSTEMS.
 *
 *===========================================================================*
 *
 * FUNCTION:   BusTools/1553-API Library:
 *             Hardware and software interrupt component. This file supports
 *             hardware interrupts and software-only interrupts.
 *
 * DESCRIPTION:
 *
 * API ENTRY POINTS: (used by libbusapi.so.)
 *    vbtInterruptSetup       Initializes hardware and/or software interrupts
 *                            for a specified adapter offset.
 *    vbtInterruptClose       Shuts down hardware and/or software interrupts
 *                            for a specified adapter.  Closes all interrupt
 *                            functions if this is the final board being closed.
 *
 * EXTERNAL NON-USER ENTRY POINTS:
 *
 * INTERNAL ROUTINES:
 *    func_PollingTimer       Timer procedure for polling the board
 *    func_HwIntWQ            Configures the driver to use a "wait queue"
 *    func_HwIntSig           Configures the driver to catch the POSIX signals
 *    handler_HwIntSig        Handler for the POSIX signal generated by the
 *                            driver when a hardware interrupt occurs
 *
 *===========================================================================*/

/* $Revision:  5.45 Release $
   Date        Revision
  ----------   ---------------------------------------------------------------
  2/21/2001    Add hardware and software interrupt support
  3/21/2006    added CEI_GET_TIME, moved POSIX and Linux specific functionality
                to lowlevel, renamed file from "linux_irq_setup" to
                "irq_setup".bch
  3/27/2007    added support for QPCX-1553. bch
  6/15/2007    replaced CEI_MUTEX_TRYLOCK with CEI_MUTEX_LOCK in timer_handler,
                hwInt_handler and vbtInterruptClose functions.  added
                vbtInterruptMode to vbtInterruptSetup and vbtInterruptClose.
                modified for vbtConfigInterrupt. bch
  12/11/2007   added support for R15-EC. bch
  11/18/2008   removed POSIX signal usage for the polling timer, so replaced
                timer_handler with timer_func.  added support for R15AMC.
                replaced the include "posix.h" with "ll_posix.h". modified
                vbtSetPolling. bch
  03/18/2009   added "wait queue" functionality. improved POSIX signaling
                functionality. bch
  07/21/2009   added support for RXMC-1553. bch
  10/23/2009   added support for RPCIe-1553. bch
  04/13/2011   added support for RXMC2-1553 and R15-LPCIe. added delay after
                creating thread in vbtInterruptSetup. bch
  10/28/2011   replaced vbtWaitForInterrupt with vbtInterruptWait. added a wait
                to func_HwIntWQ till hardware interrupts are enabled. bch
  10/10/2012   added support for RAR15-XMC and RAR15-XMC-XT. bch	
  06/25/2013   removed support for: PMC-1553, PCI-1553, Q104-1553,
                RAR-15XMC, and ISA-1553. bch
  02/24/2014   added support for the R15-PMC. bch                
  10/10/2016   added support for the R15-MPCIe. bch 
  06/14/2017   changed the polling/HWINT thread priority. modified
                vbtInterruptSetup by replacing local with global in the call
                to CEI_THREAD_CREATE. bch
*/


#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <errno.h>
#ifdef POSIX_SIGNAL
#include <sys/syscall.h>
#include <signal.h>
#endif
#include "busapi.h"
#include "apiint.h"
#include "globals.h"
#include "lowlevel.h"
#include "btdrv.h"
#include "../../../Lowlevel/ll_posix.h"

#define POSIX_ERROR -1

// lowlevel
CEI_INT vbtConfigInterrupt(CEI_UINT device, CEI_INT signal, CEI_INT pid, CEI_INT val);
CEI_INT vbtInterruptMode(CEI_UINT device, CEI_INT mode);
CEI_INT vbtInterruptWait(CEI_UINT device, CEI_INT mode, CEI_INT val);
int delay_ms(int ms);

// tracks the configuration of each API cardnum
struct {
 BT_INT num;
 BT_INT dev;
 BT_INT mode; 
 BT_INT status;  // "0" - not configured, "1" - configured
 // mutex for vbtNotify, used by both the polling and hardware interrupt handlers
 CEI_MUTEX mtxNotify;
 BT_U32BIT bmRecordTime;
} conf_cardnum[MAX_BTA];

// polling timer
#define TIMER_STOP  3
#define POLLING_TIMER_THREAD_PRIORITY  1
CEI_VOID* func_PollingTimer(CEI_VOID* val);
static CEI_THREAD thrd_PollingTimer;
BT_INT status_PollingTimer=0;  // "0" - not configured, "1" - configured

// hardware interrupts
#define HWINT_THREAD_PRIORITY  99

#ifdef POSIX_SIGNAL
// POSIX signal
// a thread is created to configure the driver to send the POSIX signal to
// this thread only, to prevent the parent process from being interrupted. Only
// supported in kernel 2.6.11 and later, so earlier versions will continue to
// have the parent process interrupted, which will affect any system sleep call,
// so recommend using the "wait queue" functionality.
struct {
 CEI_MUTEX mtx;
 CEI_EVENT evnt;
 CEI_THREAD thrd;
 CEI_INT pid;
 CEI_INT status;
 CEI_INT signal;
} HwIntSig[MAX_DEVICES];
CEI_INT func_HwIntSig(CEI_VOID* val);
CEI_VOID handler_HwIntSig(CEI_INT sig_num, siginfo_t* pSig_info, CEI_VOID* val);
#else
// "wait queue"
// a thread is created for each cardnum to block on the driver (read)
// waiting for the ISR in the driver to wake up the blocked thread.
struct {
 CEI_MUTEX mtx;
 CEI_INT status;
 CEI_THREAD thrd;
} HwIntWQ[MAX_BTA];
CEI_INT func_HwIntWQ(CEI_VOID* val);
#endif

/*===========================================================================*
 * ENTRY POINT:            v b t I n t e r r u p t S e t u p
 *===========================================================================*
 *
 * FUNCTION:    Setup specified adapter for interrupt processing.
 *
 * DESCRIPTION: Setup the hardware interrupt if hardware interrupts are
 *              enabled, and setup the polling interrupt if not setup already.
 *
 * RETURNS:
 *    BTD_OK
 *===========================================================================*/
int vbtInterruptSetup(BT_UINT cardnum, BT_INT hw_int_enable, BT_INT api_dev) {
   BT_INT status=0;
   BT_UINT irq=0;
   static BT_INT status_func=0;

   if(bt_inuse[cardnum] != 1)
     return API_BUSTOOLS_NOTINITED;

   // first execution will initialize the global variables
   if(status_func == 0) {
     status_func = 1;
     memset(&conf_cardnum, -1, sizeof(conf_cardnum));
    #ifdef POSIX_SIGNAL
     memset(&HwIntSig, 0, sizeof(HwIntSig));
    #else
     memset(&HwIntWQ, 0, sizeof(HwIntWQ));
    #endif
   }

   // if cardnum is already configured
   if(conf_cardnum[cardnum].status == 1)
     return 0;

   // initialize cardnum configuration
   if(CEI_MUTEX_CREATE(&conf_cardnum[cardnum].mtxNotify) != 0)
     return POSIX_ERROR;
   conf_cardnum[cardnum].num = cardnum;
   conf_cardnum[cardnum].dev = api_dev;
   conf_cardnum[cardnum].mode = hw_int_enable;
   conf_cardnum[cardnum].bmRecordTime = 0;

   if(conf_cardnum[cardnum].mode >= API_HW_INTERRUPT) {
     // configure the device
     if(board_is_v5_uca[cardnum])
       vbtSetHWRegister(cardnum, HWREG_WRITE_INTERRUPT, 0);
     else
       vbtSetRegister[cardnum](cardnum, HWREG_WRITE_INTERRUPT, 0);  // clear the interrupt write register
     switch(CurrentCardType[cardnum]) {
      case QPCI1553:
        // Interrupt Control: set 'INTi2 Enable' and 'PCI Interrupt Enable'
        *((BT_U16BIT*)(bt_iobase[cardnum] + 0x4C)) |= 0x48;
        break;
      case QPCX1553:
      case QCP1553:
        *((BT_U16BIT*)(bt_iobase[cardnum] + 0x68)) = 0x900;
        break;
      case Q1041553P:
      case QPM1553: // includes QPMC1553 and AMC1553
      case R15EC:
      case R15AMC:
      case RXMC1553:
      case RPCIe1553:
      case R15XMC2:
      case LPCIE1553:
      case RAR15XMCXT:
      case R15PMC:
      case MPCIE1553:
        break;
      default:
        return API_HARDWARE_NOSUPPORT;   // Current API does not support card
     };

     // initialize a thread to handle hardware interrupts from the device
    #ifdef POSIX_SIGNAL  // configure for using a POSIX signal
     if(HwIntSig[api_dev].status == 0) {
       if((status = CEI_MUTEX_CREATE(&HwIntSig[api_dev].mtx)) != BTD_OK)
         return POSIX_ERROR;
       if((status = CEI_EVENT_CREATE(&HwIntSig[api_dev].evnt)) != BTD_OK)
         return POSIX_ERROR;
       // the signal to be used by the driver to notify the signal handler
       HwIntSig[api_dev].signal = CEI_SIG_HINT;
       // create signal handler to catch signals from driver
       if(CEI_SIGNAL(CEI_CREATE, HwIntSig[api_dev].signal, &handler_HwIntSig) != BTD_OK)
         return POSIX_ERROR;
       // configure the driver
       if((status = CEI_THREAD_CREATE(&HwIntSig[api_dev].thrd, HWINT_THREAD_PRIORITY, func_HwIntSig, &conf_cardnum[cardnum].dev)) != 0)
         return POSIX_ERROR;
       HwIntSig[api_dev].status == 1;
     }
    #else  // configure for using a "wait queue"
     if(HwIntWQ[cardnum].status == 0) {
       if(CEI_MUTEX_CREATE(&HwIntWQ[cardnum].mtx) != 0)
         return POSIX_ERROR;
       CEI_MUTEX_LOCK(&HwIntWQ[cardnum].mtx);
       // create a thread for each device that waits for a hardware interrupt
       if((status = CEI_THREAD_CREATE(&HwIntWQ[cardnum].thrd, HWINT_THREAD_PRIORITY, func_HwIntWQ, &conf_cardnum[cardnum].num)) != 0)
         return POSIX_ERROR;
       HwIntWQ[cardnum].status = 1;
     }
    #endif
     // a very small delay to allow for the created thread to set, increase if needed
     MSDELAY(1);

     // enable hardware interrupts
     if((status = vbtInterruptMode(api_dev, 1)) != 0)
       return status;
    #ifndef POSIX_SIGNAL
     CEI_MUTEX_UNLOCK(&HwIntWQ[cardnum].mtx);
    #endif
     api_writehwreg_or(cardnum, HWREG_CONTROL1, CR1_INT_ENABLE);
   }

   // if S/W polling requested
   if(status_PollingTimer == 0) {
     if(conf_cardnum[cardnum].mode < API_HW_ONLY_INT) {
       vbtSetPolling(api_polling_interval, TIMER_START);
       status_PollingTimer = 1;
     }
   }

   conf_cardnum[cardnum].status = 1;

   return BTD_OK;
}


/*===========================================================================*
 * ENTRY POINT:           v b t I n t e r r u p t C l o s e
 *===========================================================================*
 *
 * FUNCTION:    Disables interrupts from the specified adapter.
 *
 * DESCRIPTION: The hardware interrupt is shutdown and the timer callback
 *              is distroyed if this is the last operational adapter.
 *
 *      It will return:
 *              Nothing.
 *===========================================================================*/
void vbtInterruptClose(BT_UINT cardnum) {
  BT_INT val, status, dev;

  // Disable the hardware interrupts from the board
  if(conf_cardnum[cardnum].mode >= API_HW_INTERRUPT) {
    if((CurrentCardType[cardnum] != QPM1553)   &&  // includes QPMC1553
       (CurrentCardType[cardnum] != QPCI1553)  &&
       (CurrentCardType[cardnum] != Q1041553P) &&
       (CurrentCardType[cardnum] != QCP1553)   &&
       (CurrentCardType[cardnum] != QPCX1553)  &&
       (CurrentCardType[cardnum] != R15EC)     &&
       (CurrentCardType[cardnum] != R15AMC)    &&
       (CurrentCardType[cardnum] != RXMC1553)  &&
       (CurrentCardType[cardnum] != RPCIe1553) &&
       (CurrentCardType[cardnum] != R15XMC2)   &&
       (CurrentCardType[cardnum] != LPCIE1553) &&
       (CurrentCardType[cardnum] != RAR15XMCXT)&&
       (CurrentCardType[cardnum] != R15PMC)    &&
       (CurrentCardType[cardnum] != MPCIE1553)) {
         return;
    }

    // Set/clear CPU_INTERRUPT_ENABLE (bit 14) of 1553_CONTROL_REG
    //  (HWREG_CONTROL1) to enable/disable interrupts.  CPU_INTERRUPT
    //  (bit 9) will be set when a HW interrupt occurs.
    // Clear interrupt by writing a zero to WRITE_INTERRUPT_BIT (Bit 9)
    //  of WRITE_INTERRUPT_REG(reg 0x16-0x17), or set it by writing a one.
    api_writehwreg_and(cardnum, HWREG_CONTROL1, (BT_U16BIT)~CR1_INT_ENABLE);
    api_writehwreg(cardnum, HWREG_WRITE_INTERRUPT, 0);

    dev = conf_cardnum[cardnum].dev;
  
   #ifndef POSIX_SIGNAL
    if(HwIntWQ[cardnum].status == 1) {
      HwIntWQ[cardnum].status = 0;
      // this will wake up the wait queue for the channel
      status = vbtInterruptWait(dev, 0, CurrentCardSlot[cardnum]);
     #ifdef BT1553_LL_DEBUG
      if(status != 0)
        printf(" <BT1553_LL_DEBUG> vbtInterruptWait (%d/%d): error - %d\n", dev, CurrentCardSlot[cardnum], status);
     #endif
      delay_ms(50);  // wait for thread to exit
      CEI_THREAD_DESTROY(&HwIntWQ[cardnum].thrd);
      CEI_MUTEX_DESTROY(&HwIntWQ[cardnum].mtx);
    }
   #endif

    // check for other cardnums that are configured for this device
    for(val=0;val<MAX_BTA;val++) {
      if((val != cardnum) && (conf_cardnum[val].dev == dev))
        break;
    }
    // if no other cardnum is configured for device, then disable hardware interrupts on the device
    if(val == MAX_BTA) {
      vbtInterruptMode(dev, 0);
     #ifdef POSIX_SIGNAL
      if(HwIntSig[dev].status == 1) {
        // disable the signal handler
        CEI_SIGNAL(CEI_DESTROY, HwIntSig[dev].signal, NULL);
        CEI_EVENT_SIGNAL(&HwIntSig[dev].evnt, &HwIntSig[dev].mtx);
        CEI_EVENT_DESTROY(&HwIntSig[dev].evnt);
        CEI_MUTEX_DESTROY(&HwIntSig[dev].mtx);
        HwIntSig[dev].status == 0;
      }
     #endif
    }
  }

  // indicate that the cardnum is not configured
  conf_cardnum[cardnum].status = 0;

  // lock the mutex to prevent the polling timer from acquiring the lock, then destroy the mutex
  if(conf_cardnum[cardnum].mode < API_HW_ONLY_INT) {
    CEI_MUTEX_LOCK(&conf_cardnum[cardnum].mtxNotify);
    CEI_MUTEX_UNLOCK(&conf_cardnum[cardnum].mtxNotify);
  }
  CEI_MUTEX_DESTROY(&conf_cardnum[cardnum].mtxNotify);
  conf_cardnum[cardnum].num = -1;
  conf_cardnum[cardnum].dev = -1;
  conf_cardnum[cardnum].mode = -1;
  conf_cardnum[cardnum].bmRecordTime = 0;

  // check if other cardnums are configured for S/W polling
  for(val=0;val<MAX_BTA;val++) {
    if((conf_cardnum[cardnum].mode > -1) && (conf_cardnum[val].mode < API_HW_ONLY_INT))
      break;
  }
  // stop the polling timer thread since all boards are closed
  if(val == MAX_BTA) {
    if(status_PollingTimer == 1) {
      vbtSetPolling(0, TIMER_STOP);
      status_PollingTimer = 0;
    }
  }
}

/*===========================================================================*
 * ENTRY POINT:           v b t S e t P o l l i n g
 *===========================================================================*
 *
 * FUNCTION:    The function sets the polling interval for the application
 *
 * DESCRIPTION: The function stop the timer set the timing interval and
 *              restarts the timer
 *
 *      It will return: status
 *
 *===========================================================================*/
BT_INT vbtSetPolling(BT_UINT polling, BT_UINT tflag) {
   switch(tflag) {
     case TIMER_STOP:
     case TIMER_RESTART:
       if(status_PollingTimer == 1) {
         status_PollingTimer = 0;
         delay_ms(api_polling_interval);
         CEI_THREAD_DESTROY(&thrd_PollingTimer);
       }
       if(tflag == TIMER_STOP)
         break;
     case TIMER_START:
       if(polling > MAX_POLLING)
         api_polling_interval = MAX_POLLING;
       else if(polling < MIN_POLLING)
         api_polling_interval = MIN_POLLING;
       else
         api_polling_interval = polling;
       if(status_PollingTimer == 0) {
         status_PollingTimer = 1;
         if(CEI_THREAD_CREATE(&thrd_PollingTimer, POLLING_TIMER_THREAD_PRIORITY, func_PollingTimer, NULL) != BTD_OK) {
           status_PollingTimer = 0;
           return BTD_TIMER_FAIL;
         }
       }
       break;
     default:
       return BTD_TIMER_FAIL;
   };

   return BTD_OK;
}

// the system sleep function can be interrupted by the POSIX signal used by the ISR
// in the driver, if the PID set in the driver is the parent process and not the
// PID of the thread. if it is then it will continue until the time has elapsed,
// but verify that your OS supports nanosleep which will return the remaining time.
int delay_ms(int ms) {
  struct timespec req, rem;

  memset(&req, 0, sizeof(req));
  memset(&rem, 0, sizeof(rem));

  req.tv_sec = ms/1000;
  req.tv_nsec = (ms%1000)*1000000;

  while(1) {
    if(nanosleep(&req, &rem) == 0)
      break;
    if(errno != EINTR) {
     #ifdef BT1553_LL_DEBUG
      printf(" <BT1553_LL_DEBUG> delay_ms: error - %d\n", errno);
     #endif
      return -1;
    }
   #ifdef BT1553_LL_DEBUG
    printf(" <BT1553_LL_DEBUG> delay_ms: interrupted %d, %d\n", rem.tv_nsec, rem.tv_sec);
   #endif
    req.tv_nsec = rem.tv_nsec;
    req.tv_sec = rem.tv_sec;
  }

  return 0;
}

// the polling thread will check each configured cardnum
CEI_VOID* func_PollingTimer(CEI_VOID* val) {
  int i;
  short wVal=0;

  while(status_PollingTimer == 1) {
    for(i=0; i < MAX_BTA; i++) {
      if(bt_inited[i] <= 0)
        continue;

      // verify that the cardnum is configured
      if(conf_cardnum[i].status == 0)
        continue;

      if(_HW_FPGARev[i] >= 0x388) {
        if(board_is_v5_uca[i])
          wVal = vbtGetRegister16(i, HWREG_HEART_BEAT);
      else
          wVal = vbtGetRegister[i](i, HWREG_HEART_BEAT);
        if(wVal == heartbeat[i])
          channel_status[i].wcs_pulse = 1;
        heartbeat[i] = wVal;
      }

      // count the time to next BM recording event
      conf_cardnum[i].bmRecordTime += api_polling_interval;

      if(CEI_MUTEX_LOCK(&conf_cardnum[i].mtxNotify) == 0) {
        vbtNotify[i](i, &conf_cardnum[i].bmRecordTime);
        CEI_MUTEX_UNLOCK(&conf_cardnum[i].mtxNotify);
      }
    }
    delay_ms(api_polling_interval);
  }
}

#ifdef POSIX_SIGNAL
// configure the driver for the signal, then wait for an event which is only
// set when closing the board.
CEI_INT func_HwIntSig(CEI_VOID* val) {
  BT_INT status=0;
  BT_INT dev = *((CEI_INT*) val);

  // configure the driver to send the specified signal to this thread ID when a
  // hardware interrupt occurs on the device.
  if((status = vbtConfigInterrupt(dev, HwIntSig[dev].signal, 0, 0)) != 0) {
   #ifdef BT1553_LL_DEBUG
    printf(" <BT1553_LL_DEBUG> vbtConfigInterrupt: error - %d / %d\n", status, errno);
   #endif
    return status;
  }

  // wait for API to close
  CEI_WAIT_FOR_EVENT(&HwIntSig[dev].evnt, INFINITE, &HwIntSig[dev].mtx);

  // set the driver to disable sending a signal for this device
  vbtConfigInterrupt(dev, 0, -1, 0);

  return 0;
}

// signal handler for the signal sent by the driver to indicate a hardware interrupt,
// checks every cardnum configured for the device.
CEI_VOID handler_HwIntSig(CEI_INT sig_num, siginfo_t* pSig_info, CEI_VOID* ucontext) {
   BT_INT i, dev = pSig_info->si_int;
   
   if(pSig_info == NULL) return;
      
   // do nothing except for a signal from the driver
   if(sig_num != HwIntSig[dev].signal) {
    #ifdef BT1553_LL_DEBUG
     printf(" <BT1553_LL_DEBUG> device %d received spurious signal: %d\n", dev, sig_num);
    #endif
     return;
   }

   for(i=0; i<MAX_BTA; i++) {
     if((conf_cardnum[i].dev == dev) && (conf_cardnum[i].status == 1)) {
       if(CEI_MUTEX_LOCK(&conf_cardnum[i].mtxNotify) == 0) {
         vbtNotify[i](i, &conf_cardnum[i].bmRecordTime);
         CEI_MUTEX_UNLOCK(&conf_cardnum[i].mtxNotify);
       }
     }
   }
}
#else
// the thread which blocks in the driver waiting for the ISR to indicate a
// hardware interrupt occured.
CEI_INT func_HwIntWQ(CEI_VOID* val) {
   BT_INT status=0;
   CEI_INT cardnum = *((CEI_INT*)val);
   BT_INT dev = conf_cardnum[cardnum].dev;
   BT_INT chan = CurrentCardSlot[cardnum];

   // wait for hardware interrupts to be enabled
   CEI_MUTEX_LOCK(&HwIntWQ[cardnum].mtx);
   CEI_MUTEX_UNLOCK(&HwIntWQ[cardnum].mtx);

   while(1) {     
     // wait on the driver to wake up this process
     if((status = vbtInterruptWait(dev, 1, chan)) < 0) {
      #ifdef BT1553_LL_DEBUG
       printf(" <BT1553_LL_DEBUG> vbtInterruptWait (%d/%d): error - %d\n", dev, chan, status);
      #endif
       return status;
     }

     if(HwIntWQ[cardnum].status == 0)
       return 0;
     if(CEI_MUTEX_LOCK(&conf_cardnum[cardnum].mtxNotify) == 0) {
       vbtNotify[cardnum](cardnum, &conf_cardnum[cardnum].bmRecordTime);
       CEI_MUTEX_UNLOCK(&conf_cardnum[cardnum].mtxNotify);
     }
     if(HwIntWQ[cardnum].status == 0)
       return 0;
   }

   return 0;
}
#endif

// gets system time (ms resolution)
CEI_ULONG CEI_GET_TIME(void) {
   BT_INT status=0;
   struct timespec time;

   if((status = clock_gettime(CLOCK_REALTIME, &time)) != 0) {
    #ifdef BT1553_LL_DEBUG
     printf(" <BT1553_LL_DEBUG> clock_gettime: error - %d\n", errno);
    #endif
     return -1;
   }

   return (CEI_ULONG)time.tv_nsec/1000000;
}
