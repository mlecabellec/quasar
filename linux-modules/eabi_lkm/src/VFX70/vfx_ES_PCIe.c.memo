
/* 

Ce fichier definit des fonctions d'E/S PCIe protegees par un verrou (le
"bigEmuabiLock") de facon a interdire les E/S PCIe simultanees vers la
memoire d'echange.

Le but recherche est de comprendre, et, mieux, de corriger, le crash observe
sur l'ISF en decembre 2014.

Le probleme suppose etant vraisemblablement lie aux acces PCIe plutot qu'aux
acces a la memoire partages, tous les acces PCIe seront proteges.
Comme ces acces sont pratiquement tous des E/S 32 bits, seules des fonctions
d'acces 32 bits sont definies ci-dessous.

L'exception : quelques acces 16 bits sont effectues dans le handler
d'interruptions isr_pmcvfx(). Ces acces seront proteges directement (et,
si possible, d'une facon globale) dans cette fonction.


QUAND      QUI   QUOI
---------- ----  --------------------------------------------------------------
12/01/2015  YG   Version initiale


*/


#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/fs.h>
#include <linux/list.h>
#include <linux/errno.h>
#include <linux/types.h>
#include <linux/pci.h>
#include <linux/delay.h>
#include <linux/interrupt.h>
#include <linux/blkdev.h>
#include <linux/moduleparam.h>
#include <linux/version.h>


#include "vfx_ctl.h"
#include "vfxvarg.h"
#include "vfxExport.h"



/* L'argument "it" des fonctions ci-dessous et un indicateur "interruption */
/* en cours" qui permet de selectionner le mode de lock approprie.         */

unsigned int
lecturePCIe(int vfxNum, int it, void * adresse)
{
    int valeur;
    vfxvarg_t * varg;
    
    varg = pvargs[vfxNum];
    
    if (it) {
        valeur = readl(adresse);
    } else {
        spin_lock_irqsave(&varg->bigEmuabiLock, varg->bigLockFlags);

        valeur = readl(adresse);
    
        spin_unlock_irqrestore(&varg->bigEmuabiLock, varg->bigLockFlags);
    }

#ifdef MONTRER_ACCES_LEFT_PORT
    if (    ((unsigned long)adresse >= (unsigned long)varg->base1)
         && ((unsigned long)adresse < (unsigned long)varg->base1 + 0x200000)) {
        printk("lecturePCIe @RAM(0x%0X) --> 0x%0X\n",
               ((unsigned long)adresse - (unsigned long)varg->base1) >> 2, valeur);
    }
#endif

    return valeur;
}


void
ecriturePCIe(int vfxNum, int it, unsigned int valeur, void * adresse)
{
    vfxvarg_t * varg;

    varg = pvargs[vfxNum];

#ifdef MONTRER_ACCES_LEFT_PORT
    if (   ((unsigned long)adresse >= (unsigned long)varg->base1)
        && ((unsigned long)adresse < (unsigned long)varg->base1 + 0x200000)) {
        printk("ecriturePCIe 0x%0X --> @RAM(0x%0X)\n",
               valeur, ((unsigned long)adresse - (unsigned long)varg->base1) >> 2);
    }
#endif

    if (it) {
        writel(valeur, adresse);
    } else {
        spin_lock_irqsave(&varg->bigEmuabiLock, varg->bigLockFlags);

        writel(valeur, adresse);

        spin_unlock_irqrestore(&varg->bigEmuabiLock, varg->bigLockFlags);
    }
}


unsigned int
lectureRamPCIe(int vfxNum, int it, unsigned int adresse)
{
    unsigned int valeur;
    vfxvarg_t * varg;
    int csr, csr1;
    int i;
    
    varg = pvargs[vfxNum];

    if (!it) {
        spin_lock_irqsave(&varg->bigEmuabiLock, varg->bigLockFlags);
    }

        /* TODO : Ce spinlock est tres dangereux.
         *        Si le powerPC est plante, on bloque le systeme !
         * Il est cependant INDISPENSABLE ici pour eviter les acces de threads
         * concurrents via un unique powerPC.
         */

    csr = readl((void *) varg->base2 + 0x9008) & ~0x6000;
    if (csr & 0x20000000) {
        // printk("ANOMALIE ACCES RAM (LEC) csr=0x%0X\n", csr);
        for (i=0; i<100; i++) {
            csr = readl((void *) varg->base2 + 0x9008) & ~0x6000;
            if ((csr & 0x20000000) == 0) break;
            udelay(1);
        }
        if (i == 100) printk("ECHEC CORRECTION ANOMALIE\n");
    }

//printk("Lecture ram 0x%08X\n", adresse);
    writel(adresse, (void *) varg->base2 + 0x90C0);
    csr1 = csr | 0x4000;
    writel(csr1, (void *) varg->base2 + 0x9008);
    
    for (i=0; i<100; i++) {
        csr1 = readl((void *) varg->base2 + 0x9008);
  // printk("i=%d csr1 = 0x%0X\n", i, csr1);
        if (csr1 & 0x20000000) break;
        udelay(1);
    }
    if (i == 100) printk("ECHEC LECTURE RAM\n");
//    printk("Lecture : i=%d\n", i);
        
    writel(csr, (void *) varg->base2 + 0x9008);
    valeur = readl((void *) varg->base2 + 0x90C4);
    
    if (!it) {
        spin_unlock_irqrestore(&varg->bigEmuabiLock, varg->bigLockFlags);
    }
    
//    printk("ram(0x%X) : 0x%08X\n", adresse, valeur);
    return valeur;
}


void
ecritureRamPCIe(int vfxNum, int it, unsigned int valeur, unsigned int adresse)
{
    vfxvarg_t * varg;
    int csr, csr1;
    int i;

    varg = pvargs[vfxNum];
    
    if (!it) {
        spin_lock_irqsave(&varg->bigEmuabiLock, varg->bigLockFlags);
    }

        /* TODO : Ce spinlock est tres dangereux.
         *        Si le powerPC est plante, on bloque le systeme !
         * Il est cependant INDISPENSABLE ici pour eviter les acces de threads
         * concurrents via un unique powerPC.
         */

    csr = readl((void *) varg->base2 + 0x9008) & ~0x6000;
    if (csr & 0x20000000) {
        // printk("ANOMALIE ACCES RAM (ECR) csr=0x%0X\n", csr);
        for (i=0; i<100; i++) {
            csr = readl((void *) varg->base2 + 0x9008) & ~0x6000;
            if ((csr & 0x20000000) == 0) break;
            udelay(1);
        }
        if (i == 100) printk("ECHEC CORRECTION ANOMALIE\n");
    }
    
//    printk("Ecriture ram(0x%X) <= 0x%08X\n", adresse, valeur);    
    writel(adresse, (void *) varg->base2 + 0x90C0);
    writel(valeur, (void *) varg->base2 + 0x90C4);
    csr1 = csr | 0x6000;
    writel(csr1, (void *) varg->base2 + 0x9008);
    
    for (i=0; i<100; i++) {
        csr1 = readl((void *) varg->base2 + 0x9008);
        if (csr1 & 0x20000000) break;
        udelay(1);
    }
    if (i == 100) printk("ECHEC ECRITURE RAM\n");
//    printk("Ecriture : i=%d\n", i);
        
    writel(csr, (void *) varg->base2 + 0x9008);
    
    if (!it) {
        spin_unlock_irqrestore(&varg->bigEmuabiLock, varg->bigLockFlags);
    }
}





