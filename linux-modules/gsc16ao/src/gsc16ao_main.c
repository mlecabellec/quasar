// vim:ts=4 expandtab:
/*****************************************************************************
 *                                                                           *
 * File:         gsc16ao_main.c                                              *
 *                                                                           *
 * Description:  Linux host driver for PCI/PMC-16AO-12 analog output card    *
 *               Main driver entry points                                    *
 *                                                                           *
 * Revision:     5.4.x_8                                                     *
 * Date:         09/06/2011                                                  *
 * History:                                                                  *
 *                                                                           *
 *  18 09/06/11 D. Dubash                                                    *
 *              Issue pci_set_master() call as DMA does is not enabled on    *
 *              some systems in the BIOS.                                    *
 *                                                                           *
 *  17 12/16/10 D. Dubash                                                    *
 *              Issue dummy read of Interrupt Status Register to reduce      *
 *              spurious interrupts being generated by the board.            *
 *                                                                           *
 *  16 12/08/10 D. Dubash                                                    *
 *              Replaced ioremap hard coded size of 4K to actual board size. * 
 *                                                                           *
 *  15 10/07/09 D. Dubash                                                    *
 *              Fixed problem where board initialization was returning to    *
 *              user before board initialization was complete.               *
 *                                                                           *
 *  14 06/23/09 D. Dubash                                                    *
 *              Increased timeout from 10 to 20 seconds as autocal was       *
 *              failing for GSC16AO-FLV cards.                               *
 *                                                                           *
 *  13 06/15/09 D. Dubash                                                    *
 *              Support for AOStream API                                     *
 *                                                                           *
 *  12 05/27/09 D. Dubash                                                    *
 *              Increased DMA burst size on expansion chassis - esp OneStop  *
 *                                                                           *
 *  11 05/05/09 D. Dubash                                                    *
 *              Initialized some control and buffer op registers in open()   *
 *                                                                           *
 *  10 03/16/09 D. Dubash                                                    *
 *              Took 5.1 and used as base for this 4.2.x_1 release           *
 *                                                                           *
 *   9 02/22/08 D. Dubash                                                    *
 *              Fix casting                                                  *
 *                                                                           *
 *   8 06/25/07 D. Dubash                                                    *
 *              Support for new GSC16AO16 sixteen channel board.             *
 *              Support for RH4.1.7 on 64_bit architecture                   *
 *                                                                           *
 *   7 02/22/07 D. Dubash                                                    *
 *              Support for rpm.                                             *
 *                                                                           *
 *   6 11/16/06 D. Dubash                                                    *
 *              Support for redHawk 4.1.7.                                   *
 *                                                                           *
 *   5 10/06/05 D. Dubash                                                    *
 *              Support for redHawk 2.3.3.                                   *
 *                                                                           *
 *   4  8/23/05 D. Dubash                                                    *
 *              Support for redHawk 2.2. Added device to card association.   *
 *                                                                           *
 *   3  8/20/03 G. Barton                                                    *
 *              Add WAIT_FOR_INTERRUPT ioctl support                         *
 *                                                                           *
 *   2  5/30/03 G. Barton                                                    *
 *              Adapted for Redhawk Linux                                    *
 *                                                                           *
 *   1  12/2002 E. Hillman (evan@generalstandards.com)                       *
 *              Created                                                      *
 *                                                                           *
 *  Copyrights (c):                                                          *
 *      Concurrent Computer Corporation, 2003                                *
 *      General Standards Corporation (GSC), Dec 2002                        *
 *****************************************************************************/

//#include <linux/config.h>
#include <linux/version.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/module.h>
#include <linux/types.h>
#include <linux/stddef.h>
#include <linux/time.h>
#include <linux/fs.h>
#include <linux/vmalloc.h>
#include <linux/sched.h>
#include <linux/poll.h>
#include <linux/init.h>
#include <linux/pci.h>
#include <linux/mm.h>
#include <linux/proc_fs.h>
#include <linux/sched.h>
#include <linux/interrupt.h>
#include <linux/timer.h>
#include <linux/ioctl.h>
#include <linux/slab.h>
#include <linux/proc_fs.h>
#include <linux/seq_file.h> /* procfs support */

#include <asm/io.h>
//#include <asm/system.h>
#include <asm/uaccess.h>

#include "gsc16ao_regs.h"
#include "gsc16ao.h"
#include "gsc16ao_ioctl.h"

#define DEFAULT_TIMEOUT MSECS_TO_SLEEP(5000)

MODULE_DESCRIPTION("");

struct board_entry boards_supported[] = {
	{GSC_SUBVENDOR,0x3120,"GSC16AO16",GSC_16AO_16},
	{GSC_SUBVENDOR,0x2405,"GSC16AO12",GSC_16AO_12},
// NEEDS TO BE SUPPORTED AND TESTED 
//	{GSC_SUBVENDOR,0x2554,"GSC16AO2",GSC_16AO_2},
	{0,0,"NULL",0},               /* null terminated list.... */
};

unsigned int gsc16ao_plx_dev[] = {PCI_DEVICE_ID_PLX_9080,
                                  0x9056,
                                  0};

/* module load/unload functions */
static int init_16ao(void);
static void exit_16ao(void);
static void _gsc16ao_set_prefetch_size(struct gsc_board *device);

/* local functions */
static ssize_t    device_write(struct file *, const char *, size_t, loff_t *);
static ssize_t    device_read(struct file *, char *, size_t, loff_t *);
static int device_open(struct inode *, struct file *);
static int device_close(struct inode *, struct file *);
static int device_mmap(struct file *, struct vm_area_struct *);
#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
static irqreturn_t device_interrupt(int irq, void *dev, struct pt_regs *regs);
#else
static irqreturn_t device_interrupt(int irq, void *dev_id);
#endif

/* local module data */
static struct file_operations device_fops = {
open:    device_open,
release: device_close,
read:    device_read,
write:   device_write,
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
unlocked_ioctl:unlocked_device_ioctl,
#else
ioctl:   device_ioctl,
#endif
mmap:    device_mmap
};

static int device_major = -1;     	  /* device major number (dynamically assigned) */
static struct gsc_board *boards = 0;  	  /* linked list of all GSC16AO boards found */
static struct gsc_board *gsc_device_list[MAX_BOARDS];

static	__s8	built[32];
static int num_boards = 0;
static int proc_enabled;
static int board_type_count[10]={0};

//#define DEBUG 1

#ifdef DEBUG
static	ulong int_other_count[MAX_BOARDS];
static	ulong int_count[MAX_BOARDS];
static	ulong dma_count[MAX_BOARDS];
static	ulong channel_irq[MAX_BOARDS];
static	ulong channel_expected[MAX_BOARDS];
static	int board_type[MAX_BOARDS];
static	void * context[MAX_BOARDS];
#endif

/*
 * Default debug class/level:
 *     Everything on, but only for critical
 */
#ifdef DEBUG
#define DEF_DLEVEL   GDL_TRACE4
#define DEF_DCLASSES  0xff
#else
#define DEF_DLEVEL   GDL_ERR
#define DEF_DCLASSES  GDC_INIT
#endif

unsigned char _debug_class_flags = DEF_DCLASSES;
unsigned char _debug_level = DEF_DLEVEL;

/************************************************************************/
/* timeout_handler                                                      */
/************************************************************************/
#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
void timeout_handler(unsigned long ptr)
#else
void timeout_handler(struct timer_list* ptr)
#endif
{
	struct gsc_board *device = (struct gsc_board *) ptr;

	prmsg(GDL_ERR, GDC_ALWAYS, "(%d): ERROR - device timeout\n", device->minor);
	prmsg(GDL_TRACE1, GDC_INTR, "(%d): timeout board control reg %.8X\n", device->minor,readlocal(device,BOARD_CTRL_REG));

	GSC16AO_LOCK(device);
	device->timeout = TRUE;

	/* Wake up whomever is waiting */
	if (device->write_wait_load_ready)
	{
		device->write_wait_load_ready = FALSE;
		wake_up(&device->writewq);
	}

	if (device->ioctl_wait_init_complete)
	{
		device->ioctl_wait_init_complete = FALSE;
		wake_up(&device->ioctlwq);
	}

	if (device->ioctl_wait_autocal_complete)
	{
		device->ioctl_wait_autocal_complete = FALSE;
		wake_up(&device->ioctlwq);
	}

	if (device->ioctl_wait_load_ready)
	{
		device->ioctl_wait_load_ready = FALSE;
		wake_up(&device->ioctlwq);
	}

	if (device->ioctl_wait_event)
	{
		device->ioctl_wait_event = 0;
		wake_up(&device->ioctlwq);
	}

	if (device->dmainprogress)
	{
		device->dmainprogress = FALSE;
		wake_up(&device->dmawq);
	}

	GSC16AO_UNLOCK(device);
}

static int gsc16ao_proc_show(struct seq_file *m, void *v);

static int gsc16ao_proc_open(struct inode *inode, struct file *file)
{
        return single_open(file, gsc16ao_proc_show, NULL);
}

#if   	 LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
static struct proc_ops gsc16ao_proc_operations = {
        .proc_open           = gsc16ao_proc_open,
        .proc_read           = seq_read,
        .proc_lseek         = seq_lseek,
        .proc_release        = single_release,
};
#else
static struct file_operations gsc16ao_proc_operations = {
        .owner          = THIS_MODULE,
        .open           = gsc16ao_proc_open,
        .read           = seq_read,
        .llseek         = seq_lseek,
        .release        = single_release,
};
#endif

static int gsc16ao_proc_show(struct seq_file *m, void *v)
{
    int bcnt;
    struct gsc_board *gsc_device = 0;
    char   flv[10];

	seq_printf(m,
		"version: %s\n"
		"built: %s\n"
		"boards: %d\n", GSC16AO_VERSION, built, num_boards);

    bcnt = 0;
    while(boards_supported[bcnt].subsystem_device != 0){
        seq_printf(m, "%-10s: %d\n",boards_supported[bcnt].name,
                    board_type_count[boards_supported[bcnt].index]);
        bcnt++;
    }

    seq_printf(m, "\n");

    for (bcnt = 0; bcnt < num_boards; bcnt++) {
        gsc_device = gsc_device_list[bcnt];
        if(gsc_device->board_info.flv)
            strcpy(flv,"(FLV)");
        else
            flv[0] = 0;

        seq_printf(m, "  card=%d: [%02x:%02x.%1d] bus=%d, slot=%d, "
                        "func=%d, firmware=0x%08x, irq=%d %s\n",
                    bcnt, gsc_device->bus, gsc_device->slot,
                    gsc_device->func, gsc_device->bus, gsc_device->slot,
                    gsc_device->func, gsc_device->board_info.firmware_ops, 
					gsc_device->irqlevel, flv);
    }

#ifdef DEBUG
    {
        int j;
	    seq_printf(m,"Debug Stats:\n ");
	    seq_printf(m,"type\tother_ints\ttotal_ints\tdma_ints\tchan_irq\tchan_expect\n");

	    for(j=0;j<num_boards;j++){
		    seq_printf(m,"%d\t\t%ld\t\t%ld\t\t%ld\t\t%ld\t\t%ld\t\t%p\n",
			    board_type[j],
			    int_other_count[j],
			    int_count[j],
			    dma_count[j],
			    channel_irq[j],
			    channel_expected[j],
			    context[j]
			    );
	    }
    }
#endif

    return(0);
}

#if 0 /* old way */
/******************************************************************************
*
*	Function:	read_proc
*
*	Purpose:
*
*		Implement the read service for the module's /proc file system
*		entry. Read the documentation on this service for details, as
*		we ignore some arguments according to our needs and the
*		documentation.
*
*	Arguments:
*
*		page	The data produced is put here.
*
*		start	Records pointer to where the data in "page" begins.
*
*		offset	The offset into the file where we're to begin.
*
*		count	The limit to the amount of data we can produce.
*
*		eof	Set this flag when we hit EOF.
*
*		data	A private data item that we may use, but don't.
*
*	Returned:
*
*		int	The number of characters written.
*
******************************************************************************/
static int _proc_read(
			 char*	page,
			 char**	start,
			 off_t	offset,
			 int	count,
			 int*	eof,
			 void*	data)
{
    char *cp;
    int bcnt;
    struct gsc_board *gsc_device = 0;

#define	_PROC_MSG_SIZE	128

#if PAGE_SIZE < _PROC_MSG_SIZE
#error	"/proc file size may be too big."
#endif
	int	i;
#ifdef DEBUG
	int j;
	char	str[256];
#endif

	if (!try_module_get (THIS_MODULE)) 
		printk ("\n<_proc_read>: Unable to increment the module count\n");

	i	= sprintf(page,
		"version: %s\n"
		"built: %s\n"
		"boards: %d\n", GSC16AO_VERSION, built, num_boards);

        cp = &page[i];

    bcnt = 0;
    while(boards_supported[bcnt].subsystem_device != 0){
        i = sprintf(cp, "%-10s: %d\n",boards_supported[bcnt].name,
                    board_type_count[boards_supported[bcnt].index]);
        cp += i;
        bcnt++;
    }

    i = sprintf(cp, "\n");
    cp += i;

    for (bcnt = 0; bcnt < num_boards; bcnt++) {
        gsc_device = gsc_device_list[bcnt];
        i = sprintf(cp, "  card=%d: [%02x:%02x.%1d] bus=%d, slot=%d, "
                        "func=%d, firmware=0x%08x, irq=%d\n",
                    bcnt, gsc_device->bus, gsc_device->slot,
                    gsc_device->func, gsc_device->bus, gsc_device->slot,
                    gsc_device->func, gsc_device->board_info.firmware_ops, 
					gsc_device->irqlevel);
        cp += i;
    }

    *cp = 0;

	//page[i]	= 0;

#ifdef DEBUG
	strcat(page, "Debug Stats:\n ");
	strcat(page,"type\tother_ints\ttotal_ints\tdma_ints\tchan_irq\tchan_expect\n");

	for(j=0;j<num_boards;j++){
		sprintf(str,"%d\t\t%ld\t\t%ld\t\t%ld\t\t%ld\t\t%ld\t\t%p\n",
			board_type[j],
			int_other_count[j],
			int_count[j],
			dma_count[j],
			channel_irq[j],
			channel_expected[j],
			context[j]
			);
		strcat(page,str);
	}

#endif
	//strcat(page, "\n");

	i	= strlen(page) + 1;

	if (i >= PAGE_SIZE) {
		prmsg(GDL_WARN, GDC_ALWAYS, ": /proc/xxx is larger than PAGE_SIZE\n");
		i= PAGE_SIZE-1;
	}

	i--;
	eof[0]	= 1;
	module_put (THIS_MODULE);
	return(i);
}

/******************************************************************************
*
*	Function:	proc_get_info
*
*	Purpose:
*
*		Implement the get_info() service for /proc file system support.
*
*	Arguments:
*
*		page	The data produced is put here.
*
*		start	Records pointer to where the data in "page" begins.
*
*		offset	The offset into the file where we're to begin.
*
*		count	The limit to the amount of data we can produce.
*
*		dummy	A parameter that is unused (for kernel 2.2 only).
*
*	Returned:
*
*		int	The number of characters written.
*
******************************************************************************/
int proc_get_info(
				  char*	page,
				  char**	start,
				  off_t	offset,
				  int	count,
				  int dummy)
{
	int	eof;
	int	i;
	
	i	= _proc_read(page, start, offset, count, &eof, NULL);
	return(i);
}
#endif

/************************************************************************/
/* module initalization: detect card(s) and set up descriptor(s)        */
/************************************************************************/
static int init_16ao(void)
{
	int index = 0;
	unsigned short reg;
	struct gsc_board *device;
	struct pci_dev *pdev = NULL;
	int i, plx_index;
	int found;
    char *board_name;
    gsc16ao_gscregs *gscptr;
    unsigned long regval;

    num_boards = 0;
    plx_index = 0;

	prmsg(GDL_TRACE1, GDC_INIT, ": driver ( version: %s) loading\n", GSC16AO_VERSION);
	sprintf(built, "%s, %s", __DATE__, __TIME__);

    while(gsc16ao_plx_dev[plx_index]) {
        prmsg(GDL_TRACE1, GDC_INIT, ": gsc16ao_plx_dev[%d]=0x%x\n",plx_index,
                                                gsc16ao_plx_dev[plx_index]);
		while ((pdev = 
//                  pci_find_device (PCI_VENDOR_ID_PLX, 
                    pci_get_device (PCI_VENDOR_ID_PLX, 
	                               gsc16ao_plx_dev[plx_index], pdev))) {
			
				prmsg(GDL_TRACE1, GDC_INIT, ": Checking...vendor: %X device: %X subvendor: %X subsystem: %X\n",pdev->vendor, pdev->device, pdev->subsystem_vendor, pdev->subsystem_device);
				if (pci_enable_device(pdev))
					continue;

                /* enable DMA master bit in case the BIOS does not enable it */
                pci_set_master(pdev);
			
				/* determine if this is one of the boards supported. */
				
				found=0;
				i=0;
				while(boards_supported[i].subsystem_device != 0){
					if ((boards_supported[i].subsystem_device == pdev->subsystem_device) &&
						(boards_supported[i].subsystem_vendor == pdev->subsystem_vendor)){
						found=1;
						prmsg(GDL_INFO, GDC_INIT, ":     found board %s type %d\n",boards_supported[i].name,i);
					}
					if (found) break;
					i++;
				}
				
				if (found){
					prmsg(GDL_INFO, GDC_INIT, ":     installing board %s type %d\n",boards_supported[i].name,i);
					pci_read_config_word(pdev, 0x2E, &reg);
					prmsg(GDL_INFO, GDC_INIT, ":     config reg=0x%x\n", reg);
					prmsg(GDL_INFO, GDC_INIT, ":     attaching board #%d\n", index + 1);
					device = (struct gsc_board *)kmalloc(sizeof(struct gsc_board), GFP_KERNEL);
					device ->board_type = i;
					/***/
					{
						int ResourceCount = 0;
						
						for (i = 0; i < PCI_NUM_BARS; ++i)
						{
						        u32 pcibase, pcisize;
							int isIO;
							/* Initialize the size field - checked in the unload */
							device->PciBar[i].Size              = 0;
							pcibase = pci_resource_start(pdev,i);
							pcisize = pci_resource_len(pdev,i);
	
							prmsg(GDL_TRACE1, GDC_INIT, "   PCI BAR %d, base=%08x, sz=%08x...", i, pcibase, pcisize);
							
							isIO = (pci_resource_flags(pdev,i) & IORESOURCE_IO) ? TRUE : FALSE;
							pcibase &= (isIO ? (~0x3) : (~0xf)); /* Paranoia - Remove flag bits */
							if (!pcibase || !pcisize) {
							  prmsg(GDL_TRACE1, GDC_INIT, ", Not a valid resource!\n");
							  continue;
							}
	
							prmsg(GDL_TRACE1, GDC_INIT, "\n");
							
							/*
							 * Reserve region
							 */
							if (isIO) {
							  if (!request_region(pcibase, pcisize, DEVICE_NAME)) {
							    prmsg(GDL_ERR, GDC_INIT, "   Cannot reserve PCI I/O region [%08x,%08x]\n");
							    continue;
							  }
							}
							else {
							  if (!request_mem_region(pcibase, pcisize, DEVICE_NAME)) {
							    prmsg(GDL_ERR, GDC_INIT, "   Cannot reserve PCI MEM region [%08x,%08x]\n");
							    continue;
							  }
							}
	
							/*
							 * Got the region
							 */
							device->PciBar[i].Physical.QuadPart = pcibase;
							device->PciBar[i].Size              = pcisize;
							device->PciBar[i].IsIoMapped        = isIO;
							
							/*
							 * Identify the claimed resources
							 */
							prmsg(GDL_INFO, GDC_INIT, "   PCI Resource %02d\n", ResourceCount);
							ResourceCount++;
	
							prmsg(GDL_INFO, GDC_INIT, "     Type     : %s\n", isIO ? "I/O Port" : "Memory Space");
							prmsg(GDL_INFO, GDC_INIT, "     Address  : %08x\n", device->PciBar[i].Physical.u.LowPart);
							if (device->PciBar[i].Size >= 1024) {
							  prmsg(GDL_INFO, GDC_INIT, "     Size     : %08x  (%d Kb)\n",	device->PciBar[i].Size, device->PciBar[i].Size / 1024);
							}
							else {
							  prmsg(GDL_INFO, GDC_INIT, "     Size     : %08x  (%d bytes)\n",device->PciBar[i].Size, device->PciBar[i].Size);
							}
						}
					}
					
					if (device->PciBar[2].IsIoMapped)
					{
						device->local_addr = (unsigned int *)(long)pdev->resource[2].start;
					}
					else
					{
						device->local_addr = (unsigned int *)ioremap(pdev->resource[2].start, (pdev->resource[2].end-pdev->resource[2].start+1));
					}
					device->runtime_addr = (unsigned int *)ioremap(pdev->resource[0].start, pci_resource_len(pdev, 0));
                    gscptr = (gsc16ao_gscregs *)device->local_addr;
	
                    /* increase DMA burst size overall */
                    /* a DMA of 8K samples (32kBytes) was taking 1.7ms on the
                     * OneStop chassis. With the fix, it went down to 
                     * 0.3ms/dma. Improvements are also seen when boards are
                     * installed on the mother board.
                     */
	                regval = readl(RunTimeCntrl(device));
	                regval &= ~0xf;
	                regval |= 0xc;
	                writel(regval, (RunTimeCntrl(device)));

					device->pdev = pdev;
					/* Set the Prefetch Size as sometimes it is not set for certain platforms. The result is that the
					 * DMA gets slower by a factor of 50 */
					_gsc16ao_set_prefetch_size(device);		

					GSC16AO_LOCK_INIT(device)
					init_waitqueue_head(&device->ioctlwq);
					init_waitqueue_head(&device->writewq);
					init_waitqueue_head(&device->dmawq);
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
                    mutex_init(&device->ioctl_mtx);
#endif
					device->irqlevel = pdev->irq;
					device->busy = 0;
					device->minor = index;
					device->next = boards;
	                device->bus = pdev->bus->number;       /* pci number */
	                device->slot = PCI_SLOT(pdev->devfn);  /* slot number */
	                device->func = PCI_FUNC(pdev->devfn);  /* function number */
	                gsc_device_list[num_boards] = device;

					prmsg(GDL_INFO, GDC_INIT, ":     base_address[2]=0x%lX, base_address[0]=0x%lX\n",pdev->resource[2].start, pdev->resource[0].start);
					prmsg(GDL_INFO, GDC_INIT, ":     local_addr=%p, runtime_addr=%p irq=%d\n", device->local_addr, device->runtime_addr, device->irqlevel);
	
					boards = device;
					device->board_index=index;
	#ifdef DEBUG
					context[index]=device;
					board_type[index]=device->board_type;
	#endif
                    device->board_info.board_type = device->board_type;
 		    strcpy(device->board_info.board_name, boards_supported[device->board_type].name);
                    switch(device->board_type) {
                        case GSC_16AO_16:
                            /* Bit D22 is set for 16AO16FLV firmware 0x201 
                             * and higher. The bit D22 is reset for 
                             * 16AO16 cards.
                             */
                            if((gscptr->firmware_ops & 0xFFF) >= 0x201) {
                                device->board_info.flv = gscptr->firmware_ops & 0x400000;
                            } else {
                                /* else, old way to distinguish the two */
                                device->board_info.flv = gscptr->firmware_ops & 0x00000F00; 
                            }
                            if(device->board_info.flv) { /* if gsc16ao_flv */
                                device->board_info.max_channels = GSC16AO16_FLV_MAX_CHANNELS;
                                device->board_info.master_clock = GSC16AO16_FLV_MASTER_CLOCK;
                                device->board_info.min_sample_freq = GSC16AO16_FLV_MIN_SAMPLE_FREQ;
                                device->board_info.max_sample_freq = GSC16AO16_FLV_MAX_SAMPLE_FREQ;
                                device->board_info.dbl_master_clock = GSC16AO16_FLV_DBL_MASTER_CLOCK;
                                device->board_info.dbl_min_sample_freq = GSC16AO16_FLV_DBL_MIN_SAMPLE_FREQ;
                                device->board_info.dbl_max_sample_freq = GSC16AO16_FLV_DBL_MAX_SAMPLE_FREQ;
                                device->board_info.differential = (gscptr->firmware_ops & (1 << 21)) >> 21;
                                device->board_info.high_level = (gscptr->firmware_ops & (1 << 20)) >> 20;
                                strcpy(device->board_info.filter,"Fx");
                                device->board_info.filter[1] = 0x30 + ((gscptr->firmware_ops & (3 << 18)) >> 18);
                            } else {
                                device->board_info.max_channels = GSC16AO16_MAX_CHANNELS;
                                device->board_info.master_clock = GSC16AO16_MASTER_CLOCK;
                                device->board_info.min_sample_freq = GSC16AO16_MIN_SAMPLE_FREQ;
                                device->board_info.max_sample_freq = GSC16AO16_MAX_SAMPLE_FREQ;
                                device->board_info.dbl_master_clock = GSC16AO16_DBL_MASTER_CLOCK;
                                device->board_info.dbl_min_sample_freq = GSC16AO16_DBL_MIN_SAMPLE_FREQ;
                                device->board_info.dbl_max_sample_freq = GSC16AO16_DBL_MAX_SAMPLE_FREQ;
                                device->board_info.differential = (gscptr->firmware_ops & (1 << 20)) >> 20;
                                switch((gscptr->firmware_ops & (3 << 18)) >> 18) {
                                    case 0:
                                        strcpy(device->board_info.filter,"(No filters)");
                                    break;
                                    case 1:
                                        strcpy(device->board_info.filter,"10kHz");
                                    break;
                                    case 2:
                                        strcpy(device->board_info.filter,"100kHz");
                                    break;
                                    case 3:
                                        strcpy(device->board_info.filter,"(reserved)");
                                    break;
                                }
                            }
                    	    device->board_info.firmware_ops = gscptr->firmware_ops;
                        break;

                        case GSC_16AO_12:
                            device->board_info.max_channels = GSC16AO12_MAX_CHANNELS;
                            device->board_info.master_clock = GSC16AO12_MASTER_CLOCK;
                            device->board_info.min_sample_freq = GSC16AO12_MIN_SAMPLE_FREQ;
                            device->board_info.max_sample_freq = GSC16AO12_MAX_SAMPLE_FREQ;
                            device->board_info.dbl_master_clock = GSC16AO12_DBL_MASTER_CLOCK;
                            device->board_info.dbl_min_sample_freq = GSC16AO12_DBL_MIN_SAMPLE_FREQ;
                            device->board_info.dbl_max_sample_freq = GSC16AO12_DBL_MAX_SAMPLE_FREQ;
                    	    device->board_info.firmware_ops = 0;
                        break;

                        case GSC_16AO_2:
                            device->board_info.max_channels = GSC16AO12_MAX_CHANNELS;
                            device->board_info.master_clock = GSC16AO12_MASTER_CLOCK;
                            device->board_info.min_sample_freq = GSC16AO12_MIN_SAMPLE_FREQ;
                            device->board_info.max_sample_freq = GSC16AO12_MAX_SAMPLE_FREQ;
                            device->board_info.dbl_master_clock = GSC16AO12_DBL_MASTER_CLOCK;
                            device->board_info.dbl_min_sample_freq = GSC16AO12_DBL_MIN_SAMPLE_FREQ;
                            device->board_info.dbl_max_sample_freq = GSC16AO12_DBL_MAX_SAMPLE_FREQ;
                    	    device->board_info.firmware_ops = 0;
                        break;
                        default:
                            printk("gsc16ao: Board type %d not supported\n",
                                device->board_type);
                        break;
                        
                    }

                    pci_dev_get(device->pdev); /* increment reference cnt*/

					index++;
					num_boards++;
                    board_type_count[device->board_type]++;

                    board_name = boards_supported[device->board_type].name;
	
	                prmsg(GDL_INFO, GDC_ALWAYS, ": /dev/%s%d: %s: PCI Bus# %d, "
	                    "Device# %d.%d, Irq=%d\n", DEVICE_NAME, device->minor, 
                        board_name, device->bus, device->slot, device->func, 
                        device->irqlevel);
				}
		}
        plx_index++;
    }

	if (index == 0) {
		prmsg(GDL_ERR, GDC_ALWAYS, ": no board found\n");
		return (-ENODEV);
	}
	device_major = register_chrdev(0, DEVICE_NAME, &device_fops);
	if (device_major < 0) {
		/* OK, could not register -- undo the work we have done above */
		prmsg(GDL_ERR, GDC_ALWAYS, ": could not register device number\n");
		exit_16ao();
		return (-ENODEV);
	}
	/*
	 *	Add /proc file system support.
	 */
	if (num_boards)
	{
#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,33)
		remove_proc_entry(DEVICE_NAME, NULL);	/* Just in case. */
#endif
        proc_enabled = 0;

#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,23)
        {
	        struct proc_dir_entry*	proc;
		    proc	= create_proc_entry(DEVICE_NAME, S_IRUGO, NULL);
		
		    if (proc)
		    {
                proc->proc_fops = &gsc16ao_proc_operations;
                proc_enabled = 1;
		    }
		    else
		    {
		        prmsg(GDL_ERR, GDC_ALWAYS, ": create_proc_entry() failure.\n");
		        exit_16ao();
                return (-ENOMEM);
		    }
        }
#else
        if((proc_create(DEVICE_NAME, S_IRUGO|S_IWUGO, NULL,
                                       &gsc16ao_proc_operations) == 0)) {
            prmsg(GDL_ERR, GDC_ALWAYS, "Could not create /proc entry\n");
		    exit_16ao();
            return (-ENOMEM);
        }
        proc_enabled = 1;
#endif
    }
	
#ifdef DEBUG
	prmsg(GDL_INFO, GDC_INIT, ": major=%d\n", device_major);
	{
		int j;
		for (j=0;j<MAX_BOARDS;j++){
			int_other_count[j]=0;
			int_count[j]=0;
			dma_count[j]=0;
			channel_irq[j]=0;
		}
	}
#endif
	prmsg(GDL_INFO, GDC_ALWAYS, ": driver version %s successfully inserted.\n", GSC16AO_VERSION);
	return 0;
}

/************************************************************************/
/* cleanup when unloading module                                        */
/************************************************************************/
static void exit_16ao(void)
{
	struct gsc_board *device, *devicenext;
	unsigned long regval;

	if (proc_enabled) {
	  remove_proc_entry(DEVICE_NAME, NULL);
	  proc_enabled	= 0;
	}
	
	if (device_major >= 0) {
	  unregister_chrdev(device_major, DEVICE_NAME);
	  device_major = -1;
	}

	for (device = boards; device; device = devicenext) {
	  int i;
	  regval = readl(IntCntrlStat(device));
	  regval &= (~PCI_INT_ENABLE);
	  writel(regval, (IntCntrlStat(device)));
	  iounmap(device->local_addr);
	  iounmap(device->runtime_addr);

	  for (i = 0; i < PCI_NUM_BARS; ++i) {
	    if (device->PciBar[i].Size) {
	      if (device->PciBar[i].IsIoMapped) {
		release_region(device->PciBar[i].Physical.QuadPart, device->PciBar[i].Size);
	      }
	      else {
		release_mem_region(device->PciBar[i].Physical.QuadPart, device->PciBar[i].Size);
	      }
	    }
	  }
	  devicenext = device->next;
                    
      pci_dev_put(device->pdev); /* decrement reference cnt*/
	  kfree(device);
	}

	boards = NULL;
	prmsg(GDL_TRACE1, GDC_INIT, ": unloaded\n");
	prmsg(GDL_INFO, GDC_ALWAYS, ": driver version %s successfully removed.\n", GSC16AO_VERSION);
}

/************************************************************************/
/* open device                                                          */
/************************************************************************/
static int device_open(struct inode *inode, struct file *fp)
{
	struct gsc_board *device;
	unsigned long regval;

	for (device = boards; device; device = device->next) {
		if (MINOR(inode->i_rdev) == device->minor) {
			if (device->busy) {
				prmsg(GDL_ERR, GDC_OPENCLOSE, "(%d): board already opened\n", device->minor);
				return (-EBUSY);
			}
			prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): opening board\n", device->minor);
#if LINUX_VERSION_CODE < KERNEL_VERSION(4,0,0)
			if (request_irq(device->irqlevel, device_interrupt,  
                        //SA_INTERRUPT | SA_SHIRQ, DEVICE_NAME, device) < 0) {
                        IRQF_DISABLED | IRQF_SHARED, DEVICE_NAME, device) < 0) {
#else
			if (request_irq(device->irqlevel, device_interrupt,  
                        IRQF_SHARED, DEVICE_NAME, device) < 0) {
#endif
				prmsg(GDL_ERR, GDC_OPENCLOSE, "(%d): cannot get interrupt %d\n", device->minor, device->irqlevel);
				device->busy = 0;
				return (-EBUSY);
			}


           /* __get_free_pages used to allocated above 16Mb range 
            *  for PCI devices. Using __get_dma_pages will limit 
            *  allocated pages to within 16MB. 
            */
            if (!(device->dmabuffer =
                (unsigned int *) __get_free_pages(GFP_KERNEL | GFP_DMA32,
                                                   DMA_ORDER))) {
				prmsg(GDL_ERR, GDC_OPENCLOSE, "(%d): can not allocate DMA pages\n", device->minor);
				free_irq(device->irqlevel, device);
				device->busy = 0;
				return (-ENOMEM);
			}

			device->dmaoffset = virt_to_phys((void *)device->dmabuffer);
			if(device->dmaoffset > 0xFFFFFFFFL) {
				prmsg(GDL_ERR, GDC_OPENCLOSE, "(%d): kernel returned memory above 4GB (0x%lx)\n", device->minor,device->dmaoffset);
				free_pages(device->dmaoffset, DMA_ORDER);
				free_irq(device->irqlevel, device);
				device->busy = 0;
				device->dmaoffset = 0;
				return (-ENOMEM);
			}
			device->dmabufsz = DMA_PAGES * PAGE_SIZE;
			prmsg(GDL_INFO, GDC_OPENCLOSE, "(%d): DMA virt=%p, phys=0x%lx, sz=%dK\n",
			      device->minor, device->dmabuffer, device->dmaoffset, device->dmabufsz/1024);
			device->timeout_seconds=20;
#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
			init_timer(&device->watchdog_timer);
			device->watchdog_timer.function=timeout_handler;
			device->watchdog_timer.data = (unsigned long) device;
#else
			timer_setup(&device->watchdog_timer, timeout_handler, 0);
#endif
			
			device->busy = 1;
			device->ulWriteMode = GSC16AO_SCAN_MODE;
			device->dmastart = FALSE;
			device->dmasamples = 0;
			device->dmainprogress = FALSE;
			device->error = GSC16AO_SUCCESS;
			device->write_wait_load_ready=FALSE;
			device->ioctl_wait_init_complete = FALSE;
			device->ioctl_wait_autocal_complete = FALSE;
			device->ioctl_wait_load_ready=FALSE;
			device->ioctl_wait_event=FALSE;
			device->ioctl_wait_event_type=0;
            device->ioctl_processing=0;

			device->calibStatus=AUTOCAL_FAILED;

			init_waitqueue_head(&device->ioctlwq);
			init_waitqueue_head(&device->writewq);
			init_waitqueue_head(&device->dmawq);

			fp->private_data = device;

			/* reset DMA engines */
			prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): resetting DMA engines\n", device->minor); 
			regval = DMA0_CLR_INT | DMA1_CLR_INT;
			writel(regval, DMACmdStatus(device));

			/* reset local IRQ flag */
			prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): resetting local IRQ flag\n", device->minor);
			regval = readlocal(device,BOARD_CTRL_REG);
			regval &= (~BCR_IRQ_MASK);
            regval &= ~(BCR_BURST_ENABLED|BCR_BURST_TRIGGER);
			writelocal(device,regval,BOARD_CTRL_REG);

            /* clear buffer and reset overflow flags */
	        regval = readlocal(device,BUFFER_OPS_REG);
            regval |= BOR_CLEAR_BUFFER; 
            regval &= ODB_EOF_FLAG; /* BUFFER OVERFLOW */
            regval &= (1<<17);  /* FRAME OVERFLOW */
	        writelocal(device,regval,BUFFER_OPS_REG);

			/* enable local interrupts */
			prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): enabling local IRQ\n", device->minor);
			regval = readl(IntCntrlStat(device));
			regval |= PCI_INT_ENABLE;
			writel(regval, (IntCntrlStat(device)));
			prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): open done\n", device->minor);

			if (!(try_module_get (THIS_MODULE))) {
				printk("device_open: Can't increment the mod count\n");
				return -EBUSY;
			}
			return (0);
		}
	}
	prmsg(GDL_ERR, GDC_OPENCLOSE, "(%d): can not find board\n", MINOR(inode->i_rdev));
	return (-ENODEV);
}

/************************************************************************/
/* close device                                                         */
/************************************************************************/
static int device_close(struct inode *inode, struct file *fp)
{
	struct gsc_board *device = (struct gsc_board *)fp->private_data;
	unsigned long regval;

	prmsg(GDL_TRACE1, GDC_OPENCLOSE, "(%d): closing board\n", device->minor);

	/* disable interrupts */
	regval = readl(IntCntrlStat(device));
	regval &= (~PCI_INT_ENABLE);
	writel(regval, (IntCntrlStat(device)));
	/* reset DMA engines */
	regval = DMA0_CLR_INT | DMA1_CLR_INT;
	writel(regval, DMACmdStatus(device));
	/* reset local IRQ flag */
	regval = readlocal(device,BOARD_CTRL_REG);
	regval &= (~BCR_IRQ_MASK);
	writelocal(device,regval,BOARD_CTRL_REG);
	/* free resources */
	free_pages((unsigned long)device->dmabuffer, DMA_ORDER);

	free_irq(device->irqlevel, device);
	device->busy = 0;
	module_put (THIS_MODULE);
	return (0);
}

/************************************************************************/
/* write operation: either polled or uses PLX DMA on CH0                 */
/************************************************************************/
static ssize_t device_write(struct file *fp, const char *buf, size_t size, loff_t * lt)
{
	struct gsc_board *device = (struct gsc_board *)fp->private_data;
	int nsamples = size / sizeof(int);
	int bor_reg;
	unsigned long regval;

	/* verify parameters */
	if (nsamples <= 0) {
		prmsg(GDL_WARN, GDC_RDWR, "(%d): device_write - zero sample return\n", device->minor);
		return (0);
	}

	if (!access_ok(
#ifdef VERIFY_READ
            VERIFY_READ,
#endif
            (unsigned long)buf, nsamples * sizeof(int))) {
		prmsg(GDL_ERR, GDC_RDWR, "(%d): device_write - access not OK\n", device->minor);
		return (-EFAULT);
	}
	
	// if in circular mode, make sure the buffer is ready.  If busy for non-blocking,
	// return immediatly.  For blocking wait for the buffer to come around.

	bor_reg = readlocal(device,BUFFER_OPS_REG);
	if ((fp->f_flags & O_NONBLOCK) && (bor_reg&BOR_CIRCULAR_BUFFER))
	{
		device->error = GSC16AO_SUCCESS;
		return (-EAGAIN);
	}
	// if circular, wait for buffer ready
	if (bor_reg&BOR_CIRCULAR_BUFFER)
	{
		device->write_wait_load_ready = TRUE;
		writel(readl(IntCntrlStat(device)) | IRQ_PCI_ENABLE | IRQ_LOCAL_PCI_ENABLE, IntCntrlStat(device));

		// enable the int passthrough
		regval = readlocal(device,BOARD_CTRL_REG);
		regval &= (~(BCR_IRQ_MASK));
		regval |= (BCR_IRQ_LOAD_READY);
		writelocal(device,regval,BOARD_CTRL_REG);

		// start wait for buffer
		regval = readlocal(device,BUFFER_OPS_REG);
		regval |= (BOR_LOAD_REQUEST);
		writelocal(device,regval,BUFFER_OPS_REG);

		device->timeout=FALSE;
		device->watchdog_timer.expires=jiffies+device->timeout_seconds*HZ;
		add_timer(&device->watchdog_timer);

		prmsg(GDL_TRACE1, GDC_RDWR, "(%d): device_write about to wait for load ready\n", device->minor);

		wait_event_interruptible(device->writewq,(!device->write_wait_load_ready));
		if (device->timeout)
		{
			prmsg(GDL_ERR, GDC_RDWR, "(%d): timeout during wait for load ready\n", device->minor);
			device->write_wait_load_ready = FALSE;
			device->error = GSC16AO_ERR_IOCTL_TIMEOUT;
			return (-EIO);
		}
		else
			del_timer_sync(&device->watchdog_timer);

		prmsg(GDL_TRACE1, GDC_RDWR, "(%d): device_write after wait for load ready\n", device->minor);
	}

	// now ready to transfer data
	if (device->ulWriteMode == GSC16AO_DMA_MODE) { // use DMA for the write.
		unsigned long regval;
		unsigned long offset = 0;

		while (nsamples) {
		  unsigned long chunksz = nsamples * sizeof(int);
		  if (chunksz > device->dmabufsz)
		    chunksz = device->dmabufsz;

		  prmsg(GDL_TRACE1, GDC_RDWR, "(%d): DMA chunksize = %d\n", device->minor, chunksz);

		  /* Copy user data to dma buffer */
		  __copy_from_user((char *)device->dmabuffer, buf+offset, chunksz);

		  prmsg(GDL_TRACE1, GDC_RDWR, "(%d): DMA buffer data: 0x%08x  0x%08x  0x%08x  0x%08x\n",
			device->minor, device->dmabuffer[0], device->dmabuffer[1],
			device->dmabuffer[2],device->dmabuffer[3]);

		  /* setup DMA 0 Mode */
		  writel(NON_DEMAND_DMA_MODE, DMAMode0(device));

		  /* Set PCI buffer address */
		  writel(device->dmaoffset, DMAPCIAddr0(device));

		  /* Set local GSC16AO Output Data Buffer Address */
		  writel(0x18, DMALocalAddr0(device));

		  /* Set DMA transfer size in bytes */
		  writel(chunksz, DMAByteCnt0(device));

		  /* Set Direction - PCI Bus to Local Bus */
		  writel(2, DMADescrPtr0(device));
		  /* Set Arbitration register */
		  writel(0, DMAArbitr(device));
		  /* Set Threshold register */
		  writel(0, DMAThreshold(device));

		  /* Clear the DMA Status */
		  regval = readl(DMACmdStatus(device));
		  regval &= STOP_DMA_CMD_0_MASK;
		  regval &= ~DMA0_ENABLE;
		  writel(regval, DMACmdStatus(device));
		  
		  /* Start the DMA GO sequence - must follow this exactly */
		  writel(regval | DMA0_CLR_INT, DMACmdStatus(device));
		  regval |= DMA0_ENABLE;
		  writel(regval, DMACmdStatus(device));
		  regval |= DMA0_START;
		  device->dmainprogress = TRUE;
		  /* Fire the DMA */
		  writel(regval, DMACmdStatus(device));

		  prmsg(GDL_TRACE1, GDC_RDWR, "(%d): device_write (DMA) - about to sleep...\n", device->minor);

		  device->timeout=FALSE;
		  device->watchdog_timer.expires=jiffies+device->timeout_seconds*HZ;
		  add_timer(&device->watchdog_timer);

		  wait_event_interruptible(device->dmawq,(!device->dmainprogress));
		  if (device->timeout)
		  {
		    prmsg(GDL_ERR, GDC_RDWR, "(%d): device_write (DMA) - timeout...\n", device->minor);
		    
		    prmsg(GDL_ERR, GDC_RDWR, "(%d): In progress: %d PXL int/ctrl %.8X BC %.8X DMA %.8X\n",
			  device->minor, device->dmainprogress, readl(IntCntrlStat(device)),
			  readlocal(device,BOARD_CTRL_REG), readl(DMACmdStatus(device)) );
		    
		    return (-ETIME);
		  }
		  else {
		    del_timer_sync(&device->watchdog_timer);
		  }
		  
		  offset += chunksz;
		  nsamples -= (chunksz/sizeof(int));
		}
	}
	else // pio
	{
		int i;
		unsigned int *dataPtr;
		unsigned int data;

		dataPtr=(unsigned int *) buf;
		device->dmainprogress = FALSE;
		
		prmsg(GDL_TRACE1, GDC_RDWR, "(%d): device_write PIO...\n", device->minor);

		for(i=0;i<nsamples;i++)
		{
			// this can probably be refined...
			__copy_from_user(&data,dataPtr+i,sizeof(unsigned int));
			writelocal(device,data, OUTPUT_BUF_REG);
		}
	}
	return size;
}

/************************************************************************/
/* read operation: easy -- just return an error                        */
/************************************************************************/
static ssize_t device_read(struct file *fp, char *buf, size_t size, loff_t * lt)
{
	struct gsc_board *device = (struct gsc_board *)fp->private_data;

	prmsg(GDL_TRACE1, GDC_RDWR, "(%d): device_read on write-only device\n", device->minor);

	return (-EPERM);
}

/************************************************************************/
/* writelocal                                                           */
/*                                                                      */
/* Write to the board local registers, whether the local registers      */
/* are in I/O space or memory space.                                    */
/*                                                                      */
/*                                                                      */
/************************************************************************/
void writelocal(struct gsc_board *device, unsigned value, unsigned address)
{
	if (device->PciBar[2].IsIoMapped) /* i/o space */
	{
		prmsg(GDL_TRACE4, GDC_REG, "(%d): writelocal I/O space addr: %.8X value: %.8X.\n",
		      device->minor, address, value);
		outl(value, (unsigned long)device->local_addr+address*4);
	}
	else
	{
	  prmsg(GDL_TRACE4, GDC_REG, "(%d): writelocal mem space addr: %.8X value: %.8X.\n",
		      device->minor, address, value);
		writel(value, device->local_addr+address);
	}
};

/************************************************************************/
/* readlocal                                                            */
/*                                                                      */
/* Read from the board local registers, whether the local registers     */
/* are in I/O space or memory space.                                    */
/*                                                                      */
/*                                                                      */
/************************************************************************/
unsigned readlocal(struct gsc_board *device, unsigned address)
{
  unsigned tmp;

	if (device->PciBar[2].IsIoMapped) /* i/o space */
	{
		prmsg(GDL_TRACE4, GDC_REG, "(%d): readlocal I/O space addr: %.8X ", device->minor, address);
		tmp = inl((unsigned long)device->local_addr+address*4);
	}
	else
	{
		prmsg(GDL_TRACE4, GDC_REG, "(%d): readlocal MEM space addr: %.8X ", device->minor, address);
		tmp = readl(device->local_addr+address);
	}

	prmsg(GDL_TRACE4, GDC_REG, "rval=%.8X.\n", tmp);
	return tmp;
};

/*************************************************/
#define CLEAR_SPURIOUS_PLX(regval,mask, desc)  { \
	if (regval & mask) \
        { \
	        writel((regval & ~mask), IntCntrlStat(device)); \
        	prmsg(GDL_TRACE1, GDC_INTR, "(%d): Unexpected interrupt %s %.8lX %.8X %.8X\n",device->minor,desc, regval,mask,~mask); \
        } \
}


/************************************************************************/
/* Interrupt handler                                                    */
/************************************************************************/
static irqreturn_t 
#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,18)
device_interrupt(int irq, void *dev_id, struct pt_regs *regs)
#else
device_interrupt(int irq, void *dev_id)
#endif
{
	struct gsc_board *device = (struct gsc_board *)dev_id;
	unsigned long intcsr;
	unsigned long localreg;
	unsigned long bcr_reg;
    unsigned board_is_initializing;

	intcsr = readl(IntCntrlStat(device));
	prmsg(GDL_TRACE2, GDC_INTR, "(%d): Interrupt(), IntCsr = 0x%08x\n", device->minor, intcsr);

	/*
	 * Determine if the interrupt is from this board.
	 */
	intcsr &= (IRQ_DMA_0_ACTIVE|IRQ_LOCAL_ACTIVE);
	if (intcsr == 0) {
	  /*
	   * Neither local interupt nor DMA interrupt! Must not be ours...
	   */
	  prmsg(GDL_TRACE2, GDC_INTR, "(%d): Interrupt not ours...\n", device->minor);

#if 0
  /* Not needed anymore -glb */
	  
	  /*
	   * Check all possible PLX interrupt sources to ensure that the
	   * current interrupt is turned off, expected or not.
	   */
	  // PLX interrupt-control registers.
	  CLEAR_SPURIOUS_PLX(intcsr,IRQ_LOCAL_LSERR_ABORT, "IRQ_LOCAL_LSERR_ABORT*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_LSERR_ABORT, "IRQ_LOCAL_LSERR_ABORT*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_LSERR_OVERFLOW, "IRQ_LOCAL_LSERR_OVERFLOW*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_GENERATE_SERR, "IRQ_GENERATE_SERR*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_MAILBOX_ENABLE, "IRQ_MAILBOX_ENABLE*");
	  //	CLEAR_SPURIOUS_PLX(intcsr, IRQ_PCI_ENABLE, "IRQ_PCI_ENABLE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_PCI_DOORBELL_ENABLE, "IRQ_PCI_DOORBELL_ENABLE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_ABORT_ENABLE, "IRQ_ABORT_ENABLE*");
	  //	CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_PCI_ENABLE, "IRQ_LOCAL_PCI_ENABLE*");
	  //	CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_ENABLE, "IRQ_LOCAL_ENABLE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_DOORBELL_ENABLE, "IRQ_LOCAL_DOORBELL_ENABLE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_DMA_1_ENABLE,"IRQ_DMA_1_ENABLE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_LOCAL_DOORBELL_ACTIVE,"IRQ_LOCAL_DOORBELL_ACTIVE*");
	  CLEAR_SPURIOUS_PLX(intcsr, IRQ_DMA_1_ACTIVE,"IRQ_DMA_1_ACTIVE*");
#endif	  

#ifdef DEBUG
	  int_other_count[device->board_index]++;
#endif
	  return IRQ_NONE;
	}

	if (intcsr & IRQ_DMA_0_ACTIVE) {
	  /*
	   * check for DMA complete interrupt
	   */
	  prmsg(GDL_TRACE2, GDC_INTR, "(%d): DMA Interrupt!\n", device->minor);
	   
	  if (device->dmainprogress) {
	    /*
	     * Yes, we've been expecting you....
	     */
	    prmsg(GDL_TRACE2, GDC_INTR, "(%d): IRQ Dma in progress...\n", device->minor);
	    localreg = readl(DMACmdStatus(device));
	    if (localreg & DMA0_DONE) {
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): IRQ Dma done... DMA Cmd/Status=0x%x\n", 
		    device->minor, localreg);

	      /* Clear the DMA Status */
	      localreg &= STOP_DMA_CMD_0_MASK;
	      localreg &= ~DMA0_ENABLE;
	      writel(localreg, DMACmdStatus(device));
	      
	      /* ack DMA interrupt */
	      localreg |= DMA0_CLR_INT;
	      writel(localreg , DMACmdStatus(device));

          /* DO NOT REMOVE OR MOVE THE FOLLOWING DUMMY READ!!!
           * RE-READING THE INTERRUPT CONTROL STATUS REGISTER AT THIS POINT 
           * AFTER CLEARING ABOVE DMA INTERRUPT REDUCES SPUREOUS INTERRUPTS
           * AS SEEN IN /proc/irq/<irq#>/spurious FILE */
          localreg = readl(IntCntrlStat(device));
	      
	      /* wake up process blocked in 'read()' */
	      device->dmainprogress = FALSE;
#ifdef DEBUG
	      dma_count[device->board_index]++;
#endif
	      wake_up(&device->dmawq);
	    }
	  }
	  else {
	    /*
	     * Unexpected DMA interrupt
	     */
	    localreg = readl(DMACmdStatus(device));
	    if (localreg & DMA0_ENABLE) {
	      /*  wipe out the DMA1 bits while here, better safe than sorry. */
	      prmsg(GDL_ERR, GDC_INTR, "(%d): Unexpected interrupt DMA0_ENABLE\n", device->minor); 
	      writel((DMA0_CLR_INT|DMA0_ABORT|DMA1_ABORT|DMA1_CLR_INT), DMACmdStatus(device)); 
	    }
	  }
	}	

	if (intcsr & IRQ_LOCAL_ACTIVE) {
	  /*
	   * Local interrupt
	   */
	  prmsg(GDL_TRACE2, GDC_INTR, "(%d): Local Interrupt!\n", device->minor);

	  bcr_reg = readlocal(device, BOARD_CTRL_REG);
	  if (bcr_reg & BCR_INTERRUPT_REQUEST_FLAG) {
#ifdef DEBUG
	    int_count[device->board_index]++;
#endif
	    /* Ack the interrupt by clearing BCR interrupt request flag */
	    writelocal(device, (bcr_reg & ~(BCR_INTERRUPT_REQUEST_FLAG)), BOARD_CTRL_REG);

	    GSC16AO_LOCK(device);
		board_is_initializing = bcr_reg & BCR_INITIALIZE;
	    
	    bcr_reg &= BCR_IRQ_MASK;
	    switch (bcr_reg) {
	      
	    case BCR_IRQ_INIT:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_INIT %p\n", device->minor,device);
          /* if we are in the middle if an initialize (board_is_initializing
           * is TRUE), i.e. the initialization is not complete, this could not
           * possibly be an init complete interrupt so do not wake user.
           * What was happening was if the user was awoken while the 
           * BCR_INITIALIZE is set, they could possibly read the bcr and
           * OR in with other bits, resulting in re-issuing a board init
           * in the middle of a board init. This was confusing the board. This
           * appeared to happen of we powered down the system and unplugged the
           * the power supply and the rebooted and issued the first board
           * initialization ioctl().
           */

           if(board_is_initializing) /* if in the middle of init, skip and wait
                                      * for init complete interrupt to occur.
                                      */
              break; 

	      if (device->ioctl_wait_init_complete) {
		device->ioctl_wait_init_complete = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;
	      
	    case BCR_IRQ_AUTOCAL_COMPLETE:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): BCR_IRQ_AUTOCAL_COMPLETE %p\n", device->minor,device);
		
		if(bcr_reg & BCR_CALIBRATION_MODE_MASK)
			device->calibStatus=AUTOCAL_FAILED;
		else
			device->calibStatus=AUTOCAL_PASSED;

		if(bcr_reg & BCR_BIT_STATUS_FLAG)
			device->calibStatus=AUTOCAL_FAILED;
		else
			device->calibStatus=AUTOCAL_PASSED;

	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): Auto Calibration %s\n", 
		  device->minor,(device->calibStatus==AUTOCAL_PASSED)?"Passed":
			  	"*** FAILED ***");
	      if (device->ioctl_wait_autocal_complete) {
		device->ioctl_wait_autocal_complete = FALSE;
		wake_up(&device->ioctlwq);
	      }
#if 0	      
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_AUTOCAL_COMPLETE) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
#endif	      
	      break;
	      
	    case BCR_IRQ_OUT_BUFFER_EMPTY:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_OUT_BUFFER_EMPTY %p\n", device->minor,device);
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_OUT_BUFFER_EMPTY) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;
	      
	    case BCR_IRQ_OUT_BUFFER_LOW_QUARTER:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_OUT_BUFFER_LOW_QUARTER %p\n", device->minor,device);
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_OUT_BUFFER_LOW_QUARTER) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;
	      
	    case BCR_IRQ_OUT_BUFFER_HIGH_QUARTER:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_OUT_BUFFER_HIGH_QUARTER %p\n", device->minor,device);
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_OUT_BUFFER_HIGH_QUARTER) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;
	      
	    case BCR_IRQ_BURST_TRIGGER_READY:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_BURST_TRIGGER_READY %p\n", device->minor,device);
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_BURST_TRIGGER_READY) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;
	      
	    case BCR_IRQ_LOAD_READY:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_LOAD_READY %p\n", device->minor,device);
	      if (device->write_wait_load_ready) {
		device->write_wait_load_ready = FALSE;
		wake_up(&device->writewq);
	      }
	      if (device->ioctl_wait_load_ready) {
		device->ioctl_wait_load_ready = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_LOAD_READY) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
	      break;

	    case BCR_IRQ_END_LOAD_READY:
	      prmsg(GDL_TRACE2, GDC_INTR, "(%d): irq BCR_IRQ_END_LOAD_READY %p\n", device->minor,device);
#if 0	      
	      if (device->ioctl_wait_event &&
		  device->ioctl_wait_event_type == BCR_IRQ_END_LOAD_READY) {
		device->ioctl_wait_event = FALSE;
		wake_up(&device->ioctlwq);
	      }
#endif	      
	      break;
	    } /* switch */

	    GSC16AO_UNLOCK(device);

	  } /* BCR IRQ flag set */
	} /* Local interrupt */
	return IRQ_HANDLED;
}


/********************************************************************
 *                                                                  *
 *      mmap() support                                              *
 *                                                                  *
 ********************************************************************/
static int device_mmap(struct file *fp, struct vm_area_struct *vma)
{
	struct gsc_board *device = (struct gsc_board *)fp->private_data;
	char *regset;
	u32 pcistart, pcisize;

	/*
	 * Validate offset
	 */
	if (vma->vm_pgoff > 1) {
	  prmsg(GDL_ERR, GDC_MMAP, "(%d): mmap: offset > PAGESIZE, pgoff=%d\n",
		device->minor, vma->vm_pgoff);
	  return (-EINVAL);
	}

	/*
	 * Offset selects which register set.
	 *    0        --> Board control regs
	 *    PAGESIZE --> PLX regs
	 *
	 * Anything else is an error
	 */
	if (!vma->vm_pgoff) {
	  /* First page maps board control reg */
	  pcistart = device->PciBar[2].Physical.u.LowPart;
	  pcisize = device->PciBar[2].Size;
	  regset = "board control";
	}
	else {
	  pcistart = device->PciBar[0].Physical.u.LowPart;
	  pcisize = device->PciBar[0].Size;
	  regset = "local (PLX)";
	}

	prmsg(GDL_INFO, GDC_MMAP, "(%d): mmap: Offset selects %s regs @ [%08x,%08x]\n",
	      device->minor, regset, pcistart, pcistart + pcisize - 1);
	/*
	 * Verify size of mapping
	 */
	if (vma->vm_end - vma->vm_start > PAGE_SIZE) {
	  prmsg(GDL_ERR, GDC_MMAP, "(%d): mmap: Attempt to map more than one page, start=0x%x, end=0x%x\n",
		device->minor, vma->vm_start, vma->vm_end);
	  return (-EINVAL);
	}

	vma->vm_flags |= VM_IO;
	
#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,9)
	vma->vm_start += (pcistart & (~PAGE_MASK)); /* actual regs may not be page aligned */
	if (remap_page_range(vma, vma->vm_start, pcistart, pcisize, vma->vm_page_prot))  {
	  prmsg(GDL_ERR, GDC_MMAP, "(%d): mmap: remap_page_range() failed\n", device->minor);
	  return(-EAGAIN);
	}
#else
	if (remap_pfn_range(vma, vma->vm_start, (pcistart >> PAGE_SHIFT), pcisize, 
            vma->vm_page_prot))  {
	  prmsg(GDL_ERR, GDC_MMAP, "(%d): mmap: remap_page_range() failed\n", device->minor);
	  return(-EAGAIN);
	}
#endif
	
	prmsg(GDL_TRACE1, GDC_MMAP, "(%d): mmap: SUCCESS!!\n", device->minor);
	return 0;
}

/*** Fix Slow DMA problem 
 *** 1) set the prefetch size limit at location 0x0068 to 2048 
 *** 2) set the prefetch size at location 0x000c to 512
 ***/
#define GSC16AO_PCI_VENDOR					0x10b5		/* PLX Technologies VendorID */
#define GSC16AO_PEX8111_DEVICE				0x8111		/* CCURDSCC PCIe-to-PCI Bridge */
#define	MAIN_CONTROL_REGISTER_INDEX_OFFSET	0x84
#define	MAIN_CONTROL_REGISTER_DATA_OFFSET	0x88
#define PCI_CONTROL_REGISTER_OFFSET			0x0C		/* 0x100C */
#define PCI_DEVICE_CONTROL_REGISTER_OFFSET	0x68

#define PREFETCH_SIZE_LIMIT_SHIFT			12			/* in PCI_DEVICE_CONTROL_REGISTER */
#define PREFETCH_SIZE_LIMIT_MASK			7			/* in PCI_DEVICE_CONTROL_REGISTER */
#define	PREFETCH_SIZE_LIMIT_128				0
#define	PREFETCH_SIZE_LIMIT_256				1
#define	PREFETCH_SIZE_LIMIT_512				2
#define	PREFETCH_SIZE_LIMIT_1024			3
#define	PREFETCH_SIZE_LIMIT_2048			4
#define	PREFETCH_SIZE_LIMIT_4096			5

#define PREFETCH_SIZE_SHIFT					27			/* in PCI_CONTROL_REGISTER */
#define PREFETCH_SIZE_MASK					7			/* in PCI_CONTROL_REGISTER */
#define	PREFETCH_SIZE_DISABLE				0
#define	PREFETCH_SIZE_64					1
#define	PREFETCH_SIZE_128					2
#define	PREFETCH_SIZE_256					3
#define	PREFETCH_SIZE_512					4
#define	PREFETCH_SIZE_1024					5
#define	PREFETCH_SIZE_2048					6
#define	PREFETCH_SIZE_4096					7			/* NEED TO ALSO SET LIMIT COMP BIT IN PECS_TLPCFG0 */

static void
_gsc16ao_set_prefetch_size(struct gsc_board *device)
{
	struct	pci_dev	*pex8111_pdev = device->pdev->bus->self;
	unsigned int reg;
	unsigned short	device_id;
	unsigned short	vendor;

	pci_read_config_dword(pex8111_pdev, 0, &reg);
	device_id = (reg & 0xFFFF0000) >> 16;
	vendor = reg & 0xFFFF;
	if((device_id != GSC16AO_PEX8111_DEVICE) ||
		(vendor != GSC16AO_PCI_VENDOR)) {
		prmsg(GDL_ERR, GDC_INIT, 
			"prefetch_size(): vendor=0x%04x device=0x%04x\n", vendor,device_id);
		return;
	}

	/*** 
	 *** Set PCI_DEVICE_CONTROL_REGISTER @ 0x0068 to 4096
	 ***/
	pci_read_config_dword(pex8111_pdev, PCI_DEVICE_CONTROL_REGISTER_OFFSET, &reg);
	prmsg(GDL_TRACE1, GDC_INIT, 
		"prefetch_size(): Before Change: PCI_DEVICE_CONTROL_REGISTER=0x%08x\n", reg);
	reg &= ~(PREFETCH_SIZE_LIMIT_MASK << PREFETCH_SIZE_LIMIT_SHIFT);
	reg |= (PREFETCH_SIZE_LIMIT_2048 << PREFETCH_SIZE_LIMIT_SHIFT);
	pci_write_config_dword(pex8111_pdev, PCI_DEVICE_CONTROL_REGISTER_OFFSET, reg);
	prmsg(GDL_TRACE1, GDC_INIT, 
		"prefetch_size(): After Change: PCI_DEVICE_CONTROL_REGISTER=0x%08x\n", reg);

	/***
	 *** Set PCI_CONTROL_REGISTER @ 0x100C to 512 
	 ***/
	/* First select the PCI_CONTROL_REGISTER_OFFSET register */
	pci_write_config_dword(pex8111_pdev, MAIN_CONTROL_REGISTER_INDEX_OFFSET, 
							PCI_CONTROL_REGISTER_OFFSET);
	/* Read it's (PCI_CONTROL_REGISTER) value */
	pci_read_config_dword(pex8111_pdev, MAIN_CONTROL_REGISTER_DATA_OFFSET,&reg);
	prmsg(GDL_TRACE1, GDC_INIT, 
		"prefetch_size(): Before Change: PCI_CONTROL_REGISTER=0x%08x\n", reg);

	/* Now, change the PREFETCH SIZE TO A GOOD VALUE */
	/* It is observed that any size between 512 and 4096 result in the same
	 * performance. Larger values means that the device would lock the bus for
	 * a longer time. Hence, we use 512 prefetch size.
	 */
	reg &= ~(PREFETCH_SIZE_MASK << PREFETCH_SIZE_SHIFT);
	reg |= (PREFETCH_SIZE_512 << PREFETCH_SIZE_SHIFT);

	/* Write it's (PCI_CONTROL_REGISTER) new value */
	pci_write_config_dword(pex8111_pdev, MAIN_CONTROL_REGISTER_DATA_OFFSET,reg);
	prmsg(GDL_TRACE1, GDC_INIT, 
		"prefetch_size(): After Change: PCI_CONTROL_REGISTER=0x%08x\n", reg);
}

module_init (init_16ao);
module_exit (exit_16ao);
