// vim:ts=4 expandtab:
/*****************************************************************************
 *                                                                           *
 * File:         gsc16ao.h                                                   *
 *                                                                           *
 * Description:  The interface to the GSC16AO Linux device driver.           *
 *                                                                           *
 * Date:         08/23/2013                                                  *
 * History:                                                                  *
 *                                                                           *
 *  31 08/23/13 D. Dubash                                                    *
 *              Support for redHawk 6.3.5                                    *
 *                                                                           *
 *  30 01/16/13 D. Dubash                                                    *
 *              Support for redHawk 6.3.3                                    *
 *                                                                           *
 *  29 12/07/12 D. Dubash                                                    *
 *              Support for redHawk 6.3.2                                    *
 *                                                                           *
 *  28 11/27/12 D. Dubash                                                    *
 *              Support for redHawk 6.0.5                                    *
 *                                                                           *
 *  27 07/27/12 D. Dubash                                                    *
 *              Support for redHawk 6.0.4                                    *
 *                                                                           *
 *  26 07/25/12 D. Dubash                                                    *
 *              Set the Prefetch Size so that DMA works properly.            *
 *                                                                           *
 *  25 05/24/12 D. Dubash                                                    *
 *              Support for redHawk 5.4.15                                   *
 *                                                                           *
 *  24 02/06/12 D. Dubash                                                    *
 *              Support for redHawk 5.4.14                                   *
 *                                                                           *
 *  23 01/12/12 D. Dubash                                                    *
 *              Support for redHawk 5.4.13                                   *
 *                                                                           *
 *  22 09/06/11 D. Dubash                                                    *
 *              Issue pci_set_master() call to enable DMA for some system    *
 *                                                                           *
 *  21 06/29/11 D. Dubash                                                    *
 *              Remove Wave Generation library and create a new package      *
 *                                                                           *
 *  20 06/27/11 D. Dubash                                                    *
 *              Support for redHawk 5.4.12                                   *
 *                                                                           *
 *  19 03/09/11 D. Dubash                                                    *
 *              The Stream Library has the following changes:                *
 *              - new amplitude and bias feature for flist structure.        *
 *              - fixed to use actual board frequency instead of user        *
 *                supplied frequency.                                        *
 *              - document update create wave files and how to set up        *
 *                calibration.                                               *
 *                                                                           *
 *  18 02/24/11 D. Dubash                                                    *
 *              Some additional error checking                               *
 *                                                                           *
 *  17 01/27/11 D. Dubash                                                    *
 *              Support for redHawk 5.4.8                                    *
 *                                                                           *
 *  16 12/16/10 D. Dubash                                                    *
 *              Issue dummy read of Interrupt Status Register to reduce      *
 *              spurious interrupts being generated by the board.            *
 *                                                                           *
 *  15 09/10/10 D. Dubash                                                    *
 *              Support for redHawk 5.4.3                                    *
 *                                                                           *
 *  14 05/12/10 D. Dubash                                                    *
 *              Support for redHawk 5.4.2                                    *
 *                                                                           *
 *  13 04/21/10 D. Dubash                                                    *
 *              Fixed some of the tests to work with 16AO12 card.            *
 *                                                                           *
 *  12 10/07/09 D. Dubash                                                    *
 *              Fixed problem where board initialization was returning to    *
 *              user before board initialization was complete.               *
 *                                                                           *
 *  11 06/23/09 D. Dubash                                                    *
 *              Modified aostream to add cpuAffinity and cpuCount            *
 *                                                                           *
 *  10 02/25/09 D. Dubash                                                    *
 *              Took 5.1 as base line for 4.2.x                              *
 *                                                                           *
 *  10 02/25/09 D. Dubash                                                    *
 *              Removed Architecture and replaced with SUPPORTED_ARCHS file  *
 *                                                                           *
 *   9 09/26/08 D. Dubash                                                    *
 *              Support for redHawk 4.2.x                                    *
 *                                                                           *
 *   8 01/29/08 D. Dubash                                                    *
 *              Support for redHawk 4.2.2                                    *
 *                                                                           *
 *   7 06/25/07 D. Dubash                                                    *
 *              Support for new GSC16AO16 sixteen channel board.             *
 *              Support for RH4.1.7 on 64_bit architecture                   *
 *                                                                           *
 *   6 03/07/07 D. Dubash                                                    *
 *              Support for rpm.                                             *
 *                                                                           *
 *   5 11/16/06 D. Dubash                                                    *
 *              Support for redHawk 4.1.7.                                   *
 *                                                                           *
 *   4 10/06/05 D. Dubash                                                    *
 *              Support for redHawk 2.3.3.                                   *
 *                                                                           *
 *   3  8/23/05 D. Dubash                                                    *
 *              Support for redHawk 2.2. Added device to card association.   *
 *                                                                           *
 *   2  5/30/03 G. Barton                                                    *
 *              Adapted for Redhawk Linux                                    *
 *                                                                           *
 *   1  2003    E. Hillman (evan@generalstandards.com)                       *
 *              Created                                                      *
 *                                                                           *
 *  Copyrights (c):                                                          *
 *      Concurrent Computer Corporation, 2003                                *
 *      General Standards Corporation (GSC), Dec 2002                        *
 *****************************************************************************/
/***
*** gsc16ao.h
***
***  General description of this file:
***  	Device driver source code for General Standards 16AO family of
***  	16-bit analog output boards. This file is part of the Linux
***  	driver source distribution for this board.
***
***  Copyrights (c):
***  	General Standards Corporation (GSC), 2003
***
***  Author:
***  	Evan Hillman (evan@generalstandards.com)
***
***  Support:
***  	Primary support for this driver is provided by GSC.
***
***  Platform (tested on, may work with others):
***  	Linux, kernel version 2.4.x, Red Hat distribution, Intel hardware.
***/

#ifndef GSC16AO_H
#define GSC16AO_H

/*****************************************************************
 *   DO NOT CHANGE THESE NAMES AS THEY ARE SEARCHED BY build_rpm * 
 *****************************************************************/
#define GSC16AO_SLERT_VERSION         "10.9_0"
#define GSC16AO_RedHawk_VERSION       "6.3.x_2"
#define GSC16AO_HARDWARE_DESC    "General Standards PMC-GSC16AO Analog Output"
/*************************************************************/

/* module name(s) */
#ifdef CONFIG_SUSE_KERNEL
    #define GSC16AO_VERSION  GSC16AO_SLERT_VERSION
#else
    #define GSC16AO_VERSION  GSC16AO_RedHawk_VERSION
#endif


#define PCI_NUM_BARS 6

/* module name NOTE:  This name must be the same as the driver binary.  The install script
   uses the name of the binary name determine if the driver is installed properly, and the
   driver uses this name to announce itself.  The name of the binary is set in Makefile.
*/
#define GSC_SUBVENDOR PCI_VENDOR_ID_PLX

#ifndef FALSE
#define FALSE (0)
#endif

#ifndef TRUE
#define TRUE (!FALSE)
#endif

struct board_entry {
	int subsystem_vendor;
	int subsystem_device;
	char name[40];
	int index;
};

#if !defined(U64)
typedef union _U64
{
	struct
	{
		u32  LowPart;
		u32  HighPart;
	}u;

	u64 QuadPart;
} U64;
#endif

// PCI BAR Space information 
typedef struct _PCI_BAR_INFO
{
	u32     *pVa;                        // BAR Kernel Virtual Address
	U64      Physical;                   // BAR Physical Address
	u32      Size;                       // BAR size
	int  IsIoMapped;                 // Memory or I/O mapped?
} PCI_BAR_INFO;

#include "gsc16ao_ioctl.h"

/* card descriptor structure */
struct gsc_board {
	struct timer_list watchdog_timer;
	struct pci_dev *pdev;       	/* the kernel PCI device descriptor */
	unsigned int *runtime_addr;    /* remmapped runtime register address space */
	unsigned int *local_addr;  	/* remmaped local register address space */
	unsigned int *dmabuffer;   	/* DMA buffer */
	unsigned long dmaoffset;    	/* physical address of above */
	unsigned long dmabufsz;   	/* DMA buffer size */
    spinlock_t    mutex_lock;       /* lock for critical section in ISR*/
    unsigned long mutex_flags;      /* SMP flags */
	long timeout;      	      	    /* timeout flag */
	int timeout_seconds;			/* time to wait before timeout (in seconds) */
	int dmasamples;     	      	/* unread samples in the DMA buffer */
	int dmastart;       	      	/* first unread sample in the DMA buffer */
	int busy;			            /* device opened */
	int irqlevel; 		            /* interrupt level */
	int minor;			            /* device minor number */
	int error;			            /* error code */
	volatile char dmainprogress; 	/* flag set when DMA is started */
	wait_queue_head_t ioctlwq;      /* queue of tasks sleeping in ioctl */
	wait_queue_head_t writewq;      	/* queue of tasks sleeping in write */
	wait_queue_head_t dmawq;      	/* queue of tasks sleeping on DMA transfer completion */
	int board_type; /* an index for which board type for drivers that support multiple types. */
	int board_index;
	int ulWriteMode;
	int calibStatus;
    int write_wait_load_ready;
    int ioctl_wait_init_complete;
    int ioctl_wait_autocal_complete;
    int ioctl_wait_load_ready;
    int ioctl_wait_event;
    int ioctl_wait_event_type;
#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
    struct mutex ioctl_mtx;
#endif
    int       ioctl_processing;           /* ioctl processing flag */
	PCI_BAR_INFO           PciBar[PCI_NUM_BARS];    // PCI BARs information
	struct gsc_board *next;     	    /* next board in linked list */
    int bus;          /* device: pci bus number */
    int slot;         /* device: slot number */
    int func;         /* device: function */

    /* board specific variables */
    board_info_t       board_info;
};

/* non-static function prototypes */
int device_ioctl(struct inode *inode, struct file *fp, unsigned int num, unsigned long arg);

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,33)
long unlocked_device_ioctl(struct file *filp,u_int iocmd,unsigned long ioarg );
#endif
/* timing and delay stuff */
#define INIT_TIMEOUT_MS       	2000 	    /* initialization timeout */
#define AUTOCAL_TIMEOUT_MS    	5000  	    /* auto calibration timeout */
#define CH_READY_TIMEOUT_MS   	500   	    /* timeout after channel setup operations */
#define MSECS_TO_SLEEP(MS)      ((MS * HZ) / 1000)

/* additional, internally used interrupt event codes */
#define NO_EVENT      	      	(-1)

/* DMA buffer size (32 kBytes on Intel) */
#define DMA_SIZE      	      	(32 * 1024)
#define DMA_PAGES      	      	((DMA_SIZE + PAGE_SIZE - 1) / PAGE_SIZE)
#define	DMA_ORDER               (get_order(DMA_PAGES * PAGE_SIZE))

/* DMA command codes */
#define START_DMA_CMD_0         0x0B
#define START_DMA_CMD_1         0xB00
#define STOP_DMA_CMD_0_MASK     0xFF01
#define STOP_DMA_CMD_1_MASK     0x00FF
#define NON_DEMAND_DMA_MODE     0x00020D43
/*#define DMA_CMD_STAT_INT_CLEAR  0x08 */
#define PCI_INT_ENABLE        	0x00050900

/* Macros to make register access easier */
/* Mapping Local Configuration Registers */
#define PciLocRange0(card)      ((card)->runtime_addr + PCI_TO_LOC_ADDR_0_RNG)
#define PciLocRemap0(card)      ((card)->runtime_addr + LOC_BASE_ADDR_REMAP_0)
#define ModeArb(card)           ((card)->runtime_addr + MODE_ARBITRATION)
#define EndianDescr(card)       ((card)->runtime_addr + BIG_LITTLE_ENDIAN_DESC)
#define PciLERomRange(card)     ((card)->runtime_addr + PCI_TO_LOC_ROM_RNG)
#define PciLERomRemap(card)     ((card)->runtime_addr + LOC_BASE_ADDR_REMAP_EXP_ROM)
#define PciLBRegDescr0(card)    ((card)->runtime_addr + BUS_REG_DESC_0_FOR_PCI_LOC)
#define LocPciRange(card)       ((card)->runtime_addr + DIR_MASTER_TO_PCI_RNG)
#define LocPciMemBase(card)     ((card)->runtime_addr + LOC_ADDR_FOR_DIR_MASTER_MEM)
#define LocPciIOBase(card)      ((card)->runtime_addr + LOC_ADDR_FOR_DIR_MASTER_IO)
#define LocPciRemap(card)       ((card)->runtime_addr + PCI_ADDR_REMAP_DIR_MASTER)
#define LocPciConfig(card)      ((card)->runtime_addr + PCI_CFG_ADDR_DIR_MASTER_IO)
#define PciLocRange1(card)      ((card)->runtime_addr + PCI_TO_LOC_ADDR_1_RNG)
#define PciLocRemap1(card)      ((card)->runtime_addr + LOC_BASE_ADDR_REMAP_1)
#define PciLBRegDescr1(card)    ((card)->runtime_addr + BUS_REG_DESC_1_FOR_PCI_LOC)

/* Mapping Runtime Registers */
#define Mailbox0(card)          ((card)->runtime_addr + MAILBOX_REGISTER_0)
#define Mailbox1(card)          ((card)->runtime_addr + MAILBOX_REGISTER_1)
#define Mailbox2(card)          ((card)->runtime_addr + MAILBOX_REGISTER_2)
#define Mailbox3(card)          ((card)->runtime_addr + MAILBOX_REGISTER_3)
#define Mailbox4(card)          ((card)->runtime_addr + MAILBOX_REGISTER_4)
#define Mailbox5(card)          ((card)->runtime_addr + MAILBOX_REGISTER_5)
#define Mailbox6(card)          ((card)->runtime_addr + MAILBOX_REGISTER_6)
#define Mailbox7(card)          ((card)->runtime_addr + MAILBOX_REGISTER_7)
#define PciLocDoorBell(card)    ((card)->runtime_addr + PCI_TO_LOC_DOORBELL)
#define LocPciDoorBell(card)    ((card)->runtime_addr + LOC_TO_PCI_DOORBELL)

/* Mapping interrupt control/status reg  */
#define IntCntrlStat(card)      ((card)->runtime_addr + INT_CTRL_STATUS)
#define RunTimeCntrl(card)      ((card)->runtime_addr + PROM_CTRL_CMD_CODES_CTRL)
#define DevVenIDc(card)         ((card)->runtime_addr + DEVICE_ID_VENDOR_ID)
#define RevID(card)             ((card)->runtime_addr + REVISION_ID)
#define MailboxReg0(card)       ((card)->runtime_addr + MAILBOX_REG_0)
#define MailboxReg1(card)       ((card)->runtime_addr + MAILBOX_REG_1)

/* Mapping DMA registers */
#define DMAMode0(card)          ((card)->runtime_addr + DMA_CH_0_MODE)
#define DMAPCIAddr0(card)       ((card)->runtime_addr + DMA_CH_0_PCI_ADDR)
#define DMALocalAddr0(card)     ((card)->runtime_addr + DMA_CH_0_LOCAL_ADDR)
#define DMAByteCnt0(card)       ((card)->runtime_addr + DMA_CH_0_TRANS_BYTE_CNT)
#define DMADescrPtr0(card)      ((card)->runtime_addr + DMA_CH_0_DESC_PTR)
#define DMAMode1(card)          ((card)->runtime_addr + DMA_CH_1_MODE)
#define DMAPCIAddr1(card)       ((card)->runtime_addr + DMA_CH_1_PCI_ADDR)
#define DMALocalAddr1(card)     ((card)->runtime_addr + DMA_CH_1_LOCAL_ADDR)
#define DMAByteCnt1(card)       ((card)->runtime_addr + DMA_CH_1_TRANS_BYTE_CNT)
#define DMADescrPtr1(card)      ((card)->runtime_addr + DMA_CH_1_DESC_PTR)
#define DMACmdStatus(card)      ((card)->runtime_addr + DMA_CMD_STATUS)
#define DMAArbitr(card)         ((card)->runtime_addr + DMA_MODE_ARBITRATION)
#define DMAThreshold(card)      ((card)->runtime_addr + DMA_THRESHOLD_REG)

/* Mapping FIFO registers */
#define OutPostQIntStat(card)   ((card)->runtime_addr + OUT_POST_Q_INT_STATUS)
#define OutPostQIntMask(card)   ((card)->runtime_addr + OUT_POST_Q_INT_MASK)
#define MsgUnitCfg(card)        ((card)->runtime_addr + MSG_UNIT_CONFIG)
#define QBaseAddr(card)         ((card)->runtime_addr + Q_BASE_ADDR)
#define InFreeHeadPtr(card)     ((card)->runtime_addr + IN_FREE_HEAD_PTR)
#define InFreeTailPtr(card)     ((card)->runtime_addr + IN_FREE_TAIL_PTR)
#define InPostHeadPtr(card)     ((card)->runtime_addr + IN_POST_HEAD_PTR)
#define InPostTailPtr(card)     ((card)->runtime_addr + IN_POST_TAIL_PTR)
#define OutFreeHeadPtr(card)    ((card)->runtime_addr + OUT_FREE_HEAD_PTR)
#define OutFreeTailPtr(card)    ((card)->runtime_addr + OUT_FREE_TAIL_PTR)
#define OutPostHeadPtr(card)    ((card)->runtime_addr + OUT_POST_HEAD_PTR)
#define OutPostTailPtr(card)    ((card)->runtime_addr + OUT_POST_TAIL_PTR)
#define QStatusCtrl(card)       ((card)->runtime_addr + Q_STATUS_CTRL_REG)

/*
#define InpDataBufReg(card)     ((card)->local_addr + INPUT_DATA_BUFFER_REG)
*/
// Interrupt Control/Status register masks

#ifndef IRQ_LOCAL_LSERR_ABORT
#define IRQ_LOCAL_LSERR_ABORT		(1 << 0)
#endif
#ifndef IRQ_LOCAL_LSERR_OVERFLOW
#define IRQ_LOCAL_LSERR_OVERFLOW	(1 << 1)
#endif
#ifndef IRQ_GENERATE_SERR
#define IRQ_GENERATE_SERR			(1 << 2)
#endif
#ifndef IRQ_MAILBOX_ENABLE
#define IRQ_MAILBOX_ENABLE			(1 << 3)
#endif
#ifndef IRQ_RESERVED1
#define IRQ_RESERVED1				(1 << 4)
#endif
#ifndef IRQ_RESERVED2
#define IRQ_RESERVED2				(1 << 5)
#endif
#ifndef IRQ_RESERVED3
#define IRQ_RESERVED3				(1 << 6)
#endif
#ifndef IRQ_RESERVED4
#define IRQ_RESERVED4				(1 << 7)
#endif
#ifndef IRQ_PCI_ENABLE
#define IRQ_PCI_ENABLE				(1 << 8)
#endif
#ifndef IRQ_PCI_DOORBELL_ENABLE
#define IRQ_PCI_DOORBELL_ENABLE		(1 << 9)
#endif
#ifndef IRQ_ABORT_ENABLE
#define IRQ_ABORT_ENABLE			(1 << 10)
#endif
#ifndef IRQ_LOCAL_PCI_ENABLE
#define IRQ_LOCAL_PCI_ENABLE		(1 << 11)
#endif
#ifndef IRQ_RETRY_ENABLE
#define IRQ_RETRY_ENABLE			(1 << 12)
#endif
#ifndef IRQ_PCI_DOORBELL_ACTIVE
#define IRQ_PCI_DOORBELL_ACTIVE		(1 << 13)
#endif
#ifndef IRQ_ABORT_ACTIVE
#define IRQ_ABORT_ACTIVE			(1 << 14)
#endif
#ifndef IRQ_LOCAL_ACTIVE
#define IRQ_LOCAL_ACTIVE			(1 << 15)
#endif
#ifndef IRQ_LOCAL_ENABLE
#define IRQ_LOCAL_ENABLE			(1 << 16)
#endif
#ifndef IRQ_LOCAL_DOORBELL_ENABLE
#define IRQ_LOCAL_DOORBELL_ENABLE	(1 << 17)
#endif
#ifndef IRQ_DMA_0_ENABLE
#define IRQ_DMA_0_ENABLE			(1 << 18)
#endif
#ifndef IRQ_DMA_1_ENABLE
#define IRQ_DMA_1_ENABLE			(1 << 19)
#endif
#ifndef IRQ_LOCAL_DOORBELL_ACTIVE
#define IRQ_LOCAL_DOORBELL_ACTIVE	(1 << 20)
#endif
#ifndef IRQ_DMA_0_ACTIVE
#define IRQ_DMA_0_ACTIVE			(1 << 21)
#endif
#ifndef IRQ_DMA_1_ACTIVE
#define IRQ_DMA_1_ACTIVE			(1 << 22)
#endif
#ifndef IRQ_BIST_ACTIVE
#define IRQ_BIST_ACTIVE				(1 << 23)
#endif
#ifndef IRQ_MASTER_ABORT
#define IRQ_MASTER_ABORT			(1 << 24)
#endif
#ifndef IRQ_DMA_0_ABORT
#define IRQ_DMA_0_ABORT				(1 << 25)
#endif
#ifndef IRQ_DMA_1_ABORT
#define IRQ_DMA_1_ABORT				(1 << 26)
#endif
#ifndef IRQ_TARGET_ABORT
#define IRQ_TARGET_ABORT			(1 << 27)
#endif
#ifndef IRQ_MAILBOX_0
#define IRQ_MAILBOX_0				(1 << 28)
#endif
#ifndef IRQ_MAILBOX_1
#define IRQ_MAILBOX_1				(1 << 29)
#endif
#ifndef IRQ_MAILBOX_2
#define IRQ_MAILBOX_2				(1 << 30)
#endif
#ifndef IRQ_MAILBOX_3
#define IRQ_MAILBOX_3				(1 << 31)
#endif

void writelocal(struct gsc_board *,unsigned value, unsigned address);
unsigned readlocal(struct gsc_board *,unsigned address);

/* Linux stuff */
#define	KILL_FASYNC(q,s,b)		kill_fasync(&(q),(s),(b))
#define	GET_PAGE(page)			get_page((page))
#define	KMALLOC_LIMIT			(128L * 1024)
#if 0 /* DRD */
#undef	MOD_DEC_USE_COUNT
#define	MOD_DEC_USE_COUNT
#undef	MOD_INC_USE_COUNT
#define	MOD_INC_USE_COUNT
#endif
#define	NOPAGE_RETURN(ul,p)		(p)
#define	NOPAGE_RETURN_TYPE		struct page*
#define	PAGE_RESERVE(vpa)	mem_map_reserve(virt_to_page((vpa)))
#define	PAGE_UNRESERVE(vpa)	mem_map_unreserve(virt_to_page((vpa)))
#define	PCI_DEVICE_LOOP(p)		pci_for_each_dev(p)
#define	PROC_GET_INFO_ARG_5
#define	REGION_IO_CHECK(a,s)		check_region(a,s)
#define	REGION_IO_RELEASE(a,s)		release_region(a,s)
#define	REGION_IO_REQUEST(a,s,n)	((int) request_region(a,s,n))
#define	REGION_MEM_CHECK(a,s)		check_mem_region(a,s)
#define	REGION_MEM_RELEASE(a,s)		release_mem_region(a,s)
#define	REGION_MEM_REQUEST(a,s,n)	((int)request_mem_region(a,s,n))
#define	SET_CURRENT_STATE(s)		current->state = (s)
#define	VIRT_TO_PAGE(p)			virt_to_page((p))
#define	VM_OFFSET_BYTES(vma)		((vma)->vm_pgoff * PAGE_SIZE)
#define	VM_OPS_UNMAP(vmo,fun)
#define	WAIT_QUEUE_ENTRY_INIT(w,c)	init_waitqueue_entry((w),(c))
#define	WAIT_QUEUE_ENTRY_T		wait_queue_t
#define	WAIT_QUEUE_HEAD_INIT(q)		init_waitqueue_head((q))
#define	WAIT_QUEUE_HEAD_T		wait_queue_head_t

#ifdef VERIFY_WRITE
#define  copy_from_user_ret(to, from, size, retval) {	   \
  if(access_ok(VERIFY_READ, from, size)) {		   \
      if(__copy_from_user(to, from, size))			   \
          return(retval);                            \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define  copy_to_user_ret(to, from, size, retval) {	   \
  if(access_ok(VERIFY_WRITE, to, size)) {		   \
      if(__copy_to_user(to, from, size))			 \
          return(retval);                            \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define get_user_ret(val, from, retval) {		   \
  if(access_ok(VERIFY_READ, from, sizeof(*(from)))) {	   \
    __get_user(val, from);				   \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define put_user_ret(val, to, retval) { 		   \
  if(access_ok(VERIFY_WRITE, to, sizeof(*(to)))) {	   \
    __put_user(val, to);				   \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
 }
#else
#define  copy_from_user_ret(to, from, size, retval) {	   \
  if(access_ok(from, size)) {		   \
      if(__copy_from_user(to, from, size))			   \
          return(retval);                            \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define  copy_to_user_ret(to, from, size, retval) {	   \
  if(access_ok(to, size)) {		   \
      if(__copy_to_user(to, from, size))			 \
          return(retval);                            \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define get_user_ret(val, from, retval) {		   \
  if(access_ok(from, sizeof(*(from)))) {	   \
    __get_user(val, from);				   \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
}
#define put_user_ret(val, to, retval) { 		   \
  if(access_ok(to, sizeof(*(to)))) {	   \
    __put_user(val, to);				   \
  }							   \
  else {						   \
    return(retval);					   \
  }							   \
 }
#endif

#define GSC16AO_LOCK_INIT(device) { spin_lock_init(&((device)->mutex_lock)); }

#define GSC16AO_LOCK(device) {							\
  spin_lock_irqsave(&((device)->mutex_lock), (device)->mutex_flags);		\
  if ((device)->next)								\
      spin_lock(&((device)->next->mutex_lock));					\
}

#define GSC16AO_UNLOCK(device) {						\
  if ((device)->next)								\
      spin_unlock(&((device)->next->mutex_lock));				\
  spin_unlock_irqrestore(&((device)->mutex_lock), (device)->mutex_flags);	\
}

#include "gsc16ao_util.h"

#endif /* GSC16AO_H */

