--- Lowlevel/ll_posix.c	2024-10-16 13:18:48.541331434 +0000
+++ Lowlevel/ll_posix.c	2024-10-16 13:18:39.281383122 +0000
@@ -516,6 +516,58 @@
 
 /****************************************************************
 *
+*  PROCEDURE - CEI_WAIT_FOR_EVENT_NO_LOCK
+*
+*  FUNCTION
+*     Waits for specified event without lock mutex.
+*
+*  RETURNS
+*     POSIX_SUCCESS
+*     POSIX_ERROR
+*     PTHREAD_COND_TIMEOUT
+****************************************************************/
+CEI_INT CEI_WAIT_FOR_EVENT_NO_LOCK(CEI_EVENT *pEvent, CEI_INT iDelay, CEI_MUTEX *pMutex) {
+  CEI_INT ret=POSIX_SUCCESS,status=POSIX_SUCCESS;
+  CEI_ULONG val_ns=0;
+  struct timespec ts;
+
+  DBG_VAL1(pEvent);
+  
+  if(iDelay == INFINITE) {
+    // block the calling thread until signaled. Sequence:  lock mutex,
+    // mutex is released while the thread waits, mutex locked again once
+    // thread is signaled, and finally mutex is unlocked.
+    ret = pthread_cond_wait(pEvent, pMutex);
+    DBG_CHK_STATUS("pthread_cond_wait", ret);
+    if(ret != 0)
+      status = POSIX_ERROR;
+  }
+  else {
+    if(clock_gettime(CLOCK_REALTIME, &ts) == 0) {
+      val_ns = (iDelay*1000000) + ts.tv_nsec;
+      ts.tv_sec += (val_ns/1000000000);
+      ts.tv_nsec = (val_ns%1000000000);
+      ret = pthread_cond_timedwait(pEvent, pMutex, &ts);
+      if(ret == ETIMEDOUT) {
+       #ifdef LL_DEBUG
+        printf(" <LL_DEBUG> timeout in pthread_cond_timedwait\n"); 
+       #endif
+        status = POSIX_TIMEOUT;
+      }
+      else {
+        DBG_CHK_STATUS("pthread_cond_timedwait", ret);
+      }
+    }
+    else {
+      printf("Error in clock_gettime - errno: %d\n",  errno);
+      status = POSIX_ERROR;
+    }
+  }
+  return status;
+}
+
+/****************************************************************
+*
 *  PROCEDURE - CEI_EVENT_SIGNAL
 *
 *  FUNCTION
